### 🔍 이 장의 keyword!

> 객체지향 프로그래밍, 상속, 프로토타입 객체, **proto** 접근자 프로퍼티, 프로토타입, 추상 연산(`OrdinaryObjectCreate`),`Object.prototype` , 프로토타입 체인, 프로퍼티 섀도잉, prototype 프로퍼티, constructor 프로퍼티, `instanceof` , 직접 상속, 정적 프로퍼티/메서드(`Object.create()`), 프로퍼티 존재 확인(`in`, `hasOwnProperty()`),프로퍼티 열거(`for…in` , `Object.keys/values/entries()`)

## 목차

1. [객체지향 프로그래밍](#191-객체지향-프로그래밍)
2. [상속과 프로토타입](#192-상속과-프로토타입)
3. [프로토타입 객체](#193-프로토타입-객체)
4. [리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입](#194-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입)
5. [프로토타입의 생성 시점](#195-프로토타입의-생성-시점)
6. [객체 생성 방식과 프로토타입의 결정](#196-객체-생성-방식과-프로토타입의-결정)
7. [프로토타입 체인](#197-프로토타입-체인)
8. [오버라이딩과 프로퍼티 섀도잉](#198-오버라이딩과-프로퍼티-섀도잉)
9. [프로토타입의 교체](#199-프로토타입의-교체)
10. [`instanceof` 연산자](#1910-instanceof-연산자)
11. [직접 상속](#1911-직접-상속)
12. [정적 프로퍼티/메서드](#1912-정적-프로퍼티메서드)
13. [프로퍼티 존재 확인](#1913-프로퍼티-존재-확인)
14. [프로퍼티 열거](#1914-프로퍼티-열거)

# 19.1 객체지향 프로그래밍

## 자바스크립트

- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어
- 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 지닌 프로토타입 기반 객체지향 프로그래밍 언어
- 객체 기반의 프로그래밍 언어이며 JS를 이루고 있는 거의 모든 것은 객체 → 원시 값 제외 나머지 값은 모두 객체

## 객체지향 프로그래밍

- 여러 개의 독립적 단위(객체)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
  - 프로그램을 명령어 or 함수 목록으로 보는 전통적 명령형 프로그래밍의 절차지향적 관점에서 벗어남
- 실세계의 실체(사물 or 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작
  - 실체: 특징이나 성질을 나타내는 속성을 가짐 ⇒ 이를 통해 실체를 인식하거나 구별 가능

### 추상화

- 다양한 속성 중 프로그램에서 필요한 속성만 간추려 내어 표현하는 것
  - 속성을 구체적으로 표현하면 다른 객체와 구별해 인식할 수 있음

### 객체

- 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
- 상태 데이터와 동작을 하나의 논리적 단위로 묶은 복합적인 자료구조
  - 프로퍼티(상태를 나타내는 데이터) + 메서드(상태 데이터를 조작하는 동작)
- 각 객체는 고유 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유 기능을 수행하며 다른 객체와 관계성 보유 가능
  - 다른 객체와 메시지를 주고받거나 데이터 처리 또한 가능
  - 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 함

# 19.2 상속과 프로토타입

## 상속

- 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것 → 객체지향 프로그래밍의 핵심 개념
- JS는 프로토타입을 기반으로 상속을 구현해 불필요한 중복을 제거함
  - 중복 제거 방법? → 기존 코드의 적극 재사용

```jsx
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // Math.PI는 원주율을 나타내는 상수
    return Math.PI * this.radius ** 2;
  };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // false

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172
```

- 생성자 함수는 동일한 프로퍼티 구조를 갖는 객체를 여러 개 생성할 때 유용
  - 하지만 위 예제에선 `Circle` 생성자 함수로 인스턴스를 생성할 때마다 `getArea` 메서드를 중복 생성 & 중복 소유
  - `radius` 프로퍼티는 일반적으로 인스턴스마다 다르지만 `getArea` 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성해 모든 인스턴스가 공유 + 사용하는 것이 바람직 ✅
  - 동일한 메서드의 중복 소유 및 생성은 불필요한 메모리 낭비를 초래하여 퍼포먼스에도 악영향

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/9a9eaf37-5700-44d9-ad30-a363e986cf8d/image.png)

- 상속을 통해 불필요한 중복 제거 가능

  - ✔️ JS는 프로토타입을 기반으로 상속을 구현함

  ```jsx
  // 생성자 함수
  function Circle(radius) {
    this.radius = radius;
  }

  /* Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
  	 공유해서 사용할 수 있도록 프로토타입에 추가한다.
  	 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다. */
  Circle.prototype.getArea = function () {
    return Math.PI * this.radius ** 2;
  };

  // 인스턴스 생성
  const circle1 = new Circle(1);
  const circle2 = new Circle(2);

  /* Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
     프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
     ⇒ Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다. */
  console.log(circle1.getArea === circle2.getArea); // true

  console.log(circle1.getArea()); // 3.141592653589793
  console.log(circle2.getArea()); // 12.566370614359172
  ```

  - Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받음
  - getArea 메서드는 단 하나만 생성되어 프토토타입(Circle.prototype)의 메서드로 할당 → Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메서드를 상속받아 사용 가능
  - 자신의 상태를 나타내는 radius 프로퍼티만 개별 소유, 내용이 동일한 메서드는 상속을 통해 공유해 사용

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/c1546cfb-ffd4-40b9-b977-b6decbf5542c/image.png)

- 상속은 코드의 재사용 관점에서 매우 유용
  - 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현 → 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위객체인 프로토타입의 자산을 공유해 사용 가능

# 19.3 프로토타입 객체

- 프로토타입 객체: 객체지향 프로그래밍의 근간을 이루는 객체 간 상속 구현을 위해 사용
  - 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공
  - 프토토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용 가능
- 모든 객체는 [[Prototype]]이란 내부 슬롯 보유
  - 이 내부 슬롯의 값은 프로토타입의 참조 (null인 경우도 존재)
  - 해당 슬롯에 저장되는 프로토타입은 객체 생성 방식에 의해 결정 ⇒ 객체 생성 시 객체 생성 방식에 따라 프로토타입 결정 후 [[Prototype]]에 저장
  - 객체 리터럴에 의해 생성된 객체의 프로토타입: Object.prototype
  - 생성자 함수에 의해 생성된 객체의 프로토타입: 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
- ✅ 모든 객체는 하나의 프로토타입을 가짐
  - 모든 프로토타입은 생성자 함수와 연결 ⇒ 객체와 프로토타입과 생성자 함수는 서로 연결
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/a5cef271-cdab-40eb-9dca-c45679bae2c7/image.png)
  - [[Prototype]] 내부 슬롯에 직접 접근 불가 → **proto** 접근자 프로퍼티로 자신의 프로토타입에 간접 접근 가능
  - 프로토타입은 자신의 **constructor 프로퍼티** 통해 **생성자 함수에 접근 가능**
  - 생성자 함수는 자신의 **prototype 프로퍼티**를 통해 **프로토타입에 접근 가능**

## 19.3.1 **proto** 접근자 프로퍼티

- 모든 객체는 **proto** 접근자 프로퍼티를 통해 자신의 프로토타입에 간접 접근 할 수 있음

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/d1876d0c-0f69-41e2-9cc4-6614bd8ae5d7/image.png)

- person 객체의 프로퍼티: `name: "Cho"`
- person 객체의 프로토타입: [[Prototype]] 내부
  - `Object.prototype` 으로, **proto** 접근자 프로퍼티를 통해 person 객체의 [[Prototype]] 내부 슬롯이 가리키는 해당 객체에 접근한 결과
  - 모든 객체는 **proto** 접근자 프로퍼티를 통해 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근 가능

### **proto**는 접근자 프로퍼티다.

- 내부 슬롯은 프로퍼티가 아니며 직접 접근 및 호출이 불가
  - 그래서 일부에 한해 간접 접근 수단이 존재
- [[Prototype]] 내부 슬롯의 값에 간접 접근 가능한 **proto** 접근자 프로퍼티
  - 접근자 프로퍼티는 자체적으로 값([[Value]])을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수 ⇒ [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/da02f808-5f09-4496-a927-b6eb86c23e4c/image.png)

- `Object.prototype` 의 접근자 프로퍼티 === **proto**
  - getter/setter 함수인 접근자 함수를 통해 프로토타입 취득 or 할당
  - 프로토타입 접근 시 내부적으로 getter 함수([[Get]])가 호출
  - 프로토타입을 통해 새로운 프로토타입 할당 시 setter함수인 ([[Set]])이 호출

```jsx
const obj = {};
const parent = { x: 1 };

// get __proto__가 호출되어 obj 객체의 프로토타입을 취득
obj.__proto__;
// set __proto__가 호출되어 obj 객체의 프로토타입을 교체
obj.__proto__ = parent;

console.log(obj.x); // 1
```

### **proto** 접근자 프로퍼티는 상속을 통해 사용된다.

- 객체가 직접 소유하는 프로퍼티가 아니라 `Object.prototype` 의 프로퍼티
  - 모든 객체는 상속을 통해 `Object.prototype.__proto__` 접근자 프로퍼티 사용 가능

```jsx
const person = { name: 'minji' };

// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.
console.log(person.hasOwnProperty('__proto__')); // false

// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}

// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
console.log({}.__proto__ === Object.prototype); // true
```

- `Object.prototype`
  - 프로토타입 체인의 종점(프로토타입 체인의 최상위 객체)
  - 해당 객체의 프로퍼티와 메서드는 모든 객체에 상속됨

### **proto** 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

- 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함

```jsx
const parert = {};
const child = {};

// child의 프로토타입을 parent로 설정
child.__proto__ = parent;
// parent 프로토타입을 child로 설정
parent.__proto__ = child; // TypeError: Cyclic __proto__ value
```

- 위 예제는 parent 객체를 child 객체의 프로토타입으로 설정 후, child 객체를 parent 객체의 프로토타입으로 설정했다.
  - 이 경우 서로가 자신의 프로토타입이 되는 비정상적인 프토토타입 체인이 발생할 수 있다. ⇒ **proto** 접근자 프로퍼티가 에러를 발생시키면서 방지
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/0d51cc91-4e63-404a-b7a1-ec481638b66c/image.png)
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 함 ⇒ 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 함
  - 서로가 자신의 프로토타입이 되는 비정상적 프로토타입 체인(순환 참조 하는 프로토타입 체인)이 만들어지면 프로토타입 체인 종점 존재 X → 프로퍼티 검색 시 무한 루프 발생

👍 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 **proto** 접근자 프로퍼티로 프로토타입 접근 및 교체하도록 구현되어 있다.

### **proto** 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

- ES5까지 ES 사양에 포함되지 않은 비표준
  - 일부 브라우저에서 지원하고 있어 브라우저 호환성을 고려해 ES6에서 표준으로 채택
- 코드 내에서 직접 사용하는 것은 권장 X
  - 모든 객체가 **proto** 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문
  - ex) Object.prototype을 상속받지 않는 객체 생성 시 (직접 상속과 같이)

```jsx
// obj는 프로토타입 체인의 종점
const obj = Object.create(null);

console.log(obj.__proto__); // undefined

console.log(Object.getPrototypeOf(obj)); // null
```

- 프로토타입의 참조 취득하고 싶은 경우 `Object.getPrototypeOf` 메서드 사용을 권장
  - `get Object.prototype.__proto__` 의 처리 내용과 일치
  - ES5에 도입, IE9이상에서 지원
- 프로토타입을 교체하고 싶은 경우 `Object.setPrototypeOf` 메서드 사용 권장
  - `set Object.prototype.__proto__` 의 처리 내용과 일치
  - ES6에서 도입, IE11 이상에서 지원

```jsx
const obj = {};
const parent = { x: 1 };

Object.getPrototypeOf(obj); // obj.__proto__;
Object.setPrototypeOf(obj, parent); // obj.__proto__ = pare
```

## 19.3.2 함수 객체의 prototype 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
  - 생성자 함수로서 호출할 수 없는 함수(화살표 함수, ES6 메서드 축약 표현)는 해당 프로퍼티 소유 X, 프로토타입 생성 X

```jsx
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```

- 생성자 함수로 호출하기 위해 정의하지 않은 일반 함수도 prototype 프로퍼티를 소유 → but, 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미 X
- 모든 객체가 가진 **proto** 접근자 프로퍼티와 함수 객체만이 가진 prtotype 프로퍼티는 결국 동일한 프로토타입을 가리킴
  - 프로퍼티의 사용 주체가 다른 것
    | 구분 | 소유 | 값 | 사용 주체 | 사용 목적 |
    | --------------------------- | ----------- | ----------------- | ----------- | ---------------------------------------------------------------------------- |
    | `__proto__` 접근자 프로퍼티 | 모든 객체 | 프로토타입의 참조 | 모든 객체 | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용 |
    | `prototype` 프로퍼티 | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 결국 Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.
console.log(Person.prototype === me.__proto__); // true
```

- 생성자 함수로 객체 생성 후 **proto** 접근자 프로퍼티와 prototype 프로퍼티로 프로타입 객체에 접근 시 동일한 프로토타입을 가리킴

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/ab334544-3d06-413a-b595-9b80d1f6e0da/image.png)

## 19.3.3 프로토타입의 constuctor 프로퍼티와 생성자 함수

- 모든 프로토타입은 constructor 프로퍼티를 가짐
  - 이는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킴
  - 이 연결은 생성자 함수 생성 시(함수 객체 생성 시) 이뤄짐

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// me 객체의 생성자 함수는 Person이다.
console.log(me.constructor === Person); // true
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/dfcebd8c-96a7-4827-af9e-576b0756c076/image.png)

- Person 생성자 함수는 me 객체 생성 → me 객체는 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결
  - me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에는 존재
    ⇒ me 객체는 프로토타입인 Person.prototype의 constructor 프로퍼티를 상속받아 사용 가능

# 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

```jsx
// obj 객체를 생성한 생성자 함수는 Object다.
const obj = new Object();
console.log(obj.constructor === Object); // true

// add 함수 객체를 생성한 생성자 함수는 Function다.
const add = new Function('a', 'b', 'return a + b');
console.log(add.constructor === Function); // true

// 생성자 함수
function Person(name) {
  this.name = name;
}

// me 객체를 생성한 생성자 함수는 Person이다.
const me = new Person('Cho');
console.log(me.constructor === Person); // true
```

- 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결되고, constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수가 된다.

```jsx
// 객체 리터럴
const obj = {};

// 함수 리터럴
const add = function (a, b) {
  return a + b;
};

// 배열 리터럴
const arr = [1, 2, 3];

// 정규표현식 리터럴
const regexp = /is/gi;
```

- 리터럴 표기법에 의한 객체 생성 방식처럼 명시적으로 new 연산자와 함께 생성자 함수를 호출해 인스턴스를 생성하지 않는 객체 생성 방식도 있다.
- 리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재

  - 하지만 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정 불가

  ```jsx
  // obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
  const obj = {};

  // 하지만 obj 객체의 생성자 함수는 Object 생성자 함수다.
  console.log(obj.constructor === Object); // true
  ```

  - obj 객체는 객체 리터럴에 의해 생성된 객체지만 Object 생성자 함수와 constructor 프로퍼티로 연결되어 있음

### Object 생성자 함수의 ECMAScript 사양

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/af24d4e7-48af-4427-b67b-f98e1a72bf6a/image.png)

- 2번에서 Object 생성자 함수에 인수를 전달하지 않거나 undefined 또는 null을 인수로 전달하면서 호출하면 내부적으로는 추상 연산 `OrdinaryObjectCreate` 를 호출해 `Object.prototype` 을 프로토타입으로 갖는 빈 객체를 생성한다.
- **추상 연산**: ES 사양에서 내부 동작의 구현 알고리즘을 표현한 것, 사양 설명을 위해 사용되는 함수와 유사한 의사코드로 이해하자.

```jsx
// 1. new.target이 undefined나 Object가 아닌 경우
// 인스턴스 -> Foo.prototype -> Object.prototype 순으로 프로토타입 체인이 생성된다.
class Foo extends Object {}
new Foo(); // Foo {}

// 2. Object 생성자 함수에 의한 객체 생성
// Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.
// 인수가 전달되지 않았을 때 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다.
let obj = new Object();
console.log(obj); // {}

// 3. 인수가 전달된 경우에는 인수를 객체로 변환한다.
// Number 객체 생성
obj = new Object(123);
console.log(obj); // Number {123}

// String  객체 생성
obj = new Object('123');
console.log(obj); // String {"123"}
```

### OrdinaryObjectCreate

- 객체 리터럴 평가 시 추상 연산을 수행하는 `OrdinaryObjectCreate` 를 호출해 빈 객체를 생성하고 프로퍼티를 추가하도록 정의되어 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/9792ac50-8920-4a7e-badb-d4a853347b8c/image.png)

### Object 생성자 함수 호출과 객체 리터럴 평가

- 추상 연산 `OrdinaryObjectCreate` 를 호출해 빈 객체를 생성하는 것은 동일
  - new.target의 확인, 프로퍼티 추가 등 세부 내용의 차이점 존재 ⇒ 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.
- 함수 객체의 경우에도 `Function` 생성자 함수를 사용하지 않고 선언 → constructor 프로퍼티를 통해 확인 → 생성자 함수가 `Function` 생성자 함수임을 알 수 있다.
- 리터럴 표기법에 의해 생성된 객체도 상속을 위한 프로토타입이 필요
  - 가상적인 생성자 함수를 가짐 ⇒ 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼터에 의해 연결되어 있음
  - **프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.**
- 두 생성 방식에 있어 본질적인 면에서 큰 차이는 없지만, 리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니라는 것
  - 생성 과정에 미묘한 차이는 있지만 객체로서 동일한 특성을 갖는다 ✅
- 프로토타입의 constructor 프로퍼티를 통해 연결된 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 된다.
  - 리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결되며, 결국 모든 객체는 생성자 함수와 연결되어 있다.

### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

| 리터럴 표기법      | 생성자 함수 | 프로토타입         |
| ------------------ | ----------- | ------------------ |
| 객체 리터럴        | Object      | Object.prototype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리터럴        | Array       | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.prototype   |

# 19.5 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성
  - 프로토타입은 단독 존재 불가, 언제나 쌍으로 존재하기 때문 (19.4절 참고)
- 생성자 함수
  - 사용자가 직접 정의한 사용자 정의 함수
  - 자바스크립트가 기본으로 제공하는 빌트인 생성자 함수

## 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

- 내부 메서드 [[Construct]]를 갖는 함수 객체 (함수 선언문, 함수 표현식으로 정의한 일반 함수)는 `new` 연산자와 함께 생성자 함수로서 호출 가능
- **생성자 함수로서 호출할 수 있는 함수(constructor)는 함수 정의가 평가되어 함수 객체를 생성하는 시점**에 프로토타입도 더불어 생성됨

```jsx
// 호이스팅으로 선언문에 도달하기 전에 함수 객체가 생성된다.
console.log(Person.prototype); // {constructor: ƒ}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

- 생성자 함수로서 호출할 수 없는 함수(non-constructor)는 프로토타입 생성X

```jsx
const Person = (name) => {
  this.name = name;
};

console.log(Person.prototype); // undefined
```

함수 선언문은 런타인 이전 JS 엔진에 의해 먼저 실행 → 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 됨 → 이때 프로토타입도 더불어 생성 → 생성된 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩

### Person 생성자 함수와 더불어 생성된 프로토타입의 내부 살펴보기

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/4160775f-a8ca-404c-b067-a4cc96801458/image.png)

- 생성된 프로토타입은 오직 constructor 프로퍼티만을 갖는 객체
  - 프로토타입도 객체, 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 가짐
  - 생성된 프로토타입의 프로토타입은 `Object.prototype`

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/e6e47ac6-25cb-4c68-9018-48ba51a73e5d/image.png)

⇒ ✅ 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩 된다.

## 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점

- 빌트인 생성자 함수도 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됨
  - 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성됨
  - 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩됨

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/b38c9cf9-eaa9-4638-a81d-ea970083716f/image.png)

- 전역 객체?
  - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체

⇒ 객체 생성 이전 생성자 함수와 프로토타입은 이미 객체화되어 존재, 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다. 이로써 생성된 객체는 프로토타입을 상속받는다.

# 19.6 객체 생성 방식과 프로토타입의 결정

### 다양한 객체 생성 방식

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### 객체 생성 방식의 공통점

- 추상 연산 `OrdinaryObjectCreate` 에 의해 생성
  - 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받고 자신이 생성할 객체에 추가할 프로퍼티 목록을 옵션으로 전달 가능
  - 빈 객체 생성 후, 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우 프로퍼티를 객체에 추가 → 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당 → 생성한 객체 반환
- 프로토타입은 추상 연산 `OrdinaryObjectCreate` 에 전달되는 인수에 의해 결정(객체가 생성되는 시점에 객체 생성 방식에 의해 결정)

## 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

- 자바스크립트 엔진은 객체 리터럴을 평가해 객체 생성 시 추상 연산 `OrdinaryObjectCreate`를 호출
  - 이때 추상 연산에 전달되는 프로토타입은 `Object.prototype`
  - *객체 리터럴에 의해 생성되는 객체의 프로토타입*이 **`Object.prototype`** 임을 의미
- `const obj = { x: 1 };` 의 객체 리터럴이 평가될 때

  - 추상 연산 `OrdinaryObjectCreate` 에 의해 Object 생성자 함수와 `Object.prototype` 과 생성된 객체 사이에 연결이 만들어짐
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/99b39017-45fa-4f0b-b21f-4aa96f7682b1/image.png)

  ```jsx
  const obj = { x: 1 };

  // 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
  console.log(obj.constructor === Object); // true
  console.log(obj.hasOwnProperty('x')); // true
  ```

  ⇒ 객체 리터럴에 의해 생성된 객체는 `Object.prototype` 을 프로토타입으로 가지며 이를 상속 받는다.

  - 따라서 constructor 프로퍼티와 hasOwnProperty 메서드등을 상속받아 자유롭게 사용 가능하다.

## 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입

- Object 생성자 함수를 인수없이 호출하면 빈 객체가 생성
  - 호출 시 객체 리터럴과 마찬가지로 추상 연산 `OrdinaryObjectCreate` 가 호출
  - 추상 연산에 전달되는 프로토타입은 `Object.prototype`
  - `*Object` 생성자 함수에 의해 생성되는 객체의 프로토타입\*은 **`Object.prototype`** 임을 의미

```jsx
const obj = new Object();
obj.x = 1;
```

- 위 코드 실행 시 추상 연산 `OrdinaryObjectCreate` 에 의해 그림과 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어짐 ⇒ 객체 리터럴에 의해 생성된 객체와 동일한 구조

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/1a9e9c4f-c28f-4a55-aaa2-9768e7a12af2/image.png)

⇒ Object 생성자 함수에 의해 생성된 obj 객체는 `Object.prototype` 을 프로토타입으로 갖게 되며, `Object.prototype` 을 상속받는다.

```jsx
const obj = new Object();
obj.x = 1;

// Object 생성자 함수에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x')); // true
```

### 객체 리터럴과 Object 생성자 함수에 의한 객체 생성 방식의 차이

- 프로퍼티를 추가하는 방식
  - 객체 리터럴 방식: 객체 리터럴 내부에 프로퍼티를 추가
  - Object 생성자 함수 방식: 일단 빈 객체 생성 후 프로퍼티를 추가

## 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입

- new 연산자와 함께 생성자 함수를 호출해 인스턴스 생성 시 다른 객체 생성 방식과 마찬가지로 추상 연산 `OrdinaryObjectCreate` 가 호출
  - 이때 추상 연산 `OrdinaryObjectCreate` 에 전달되는 프로토타입 → 생성자 함수의 prototype 프로퍼티에 바인딩되어있는 객체
- *생성자 함수에 의해 생성되는 객체의 프로토타입*은 **생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체**

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
```

- 위 코드 실행 시 추상 연산 `OrdinaryObjectCreate` 에 의해 그림과 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 생성된 객체 사이에 연결이 만들어짐

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/8574eb6c-90eb-477d-ad20-0d8f04148282/image.png)

- 표준 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 `Object.prototype` 은 다양한 빌트인 메서드 보유
  - but, 사용자 정의 생성자 함수와 더불어 생성된 Person.prototype의 프로퍼티는 constructor뿐

### 프로토타입에 프로퍼티를 추가해 하위 객체가 상속받을 수 있게 구현하기

```jsx
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
const you = new Person('Kim');

me.sayHello(); // Hi! My name is Lee
you.sayHello(); // Hi1 My name is Kim
```

- 프로토타입은 객체라 일반 객체처럼 프로퍼티 추가/삭제 가능
  - 추가/삭제된 프로퍼티는 프로토타입 체인에 즉각 반영
- Person 생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 sayHello 메서드를 상속받아 자신의 메서드처럼 사용 가능

# 19.7 프로토타입 체인

```jsx
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');

console.log(me.hasOwnProperty('name')); // true
```

- person 생성자 함수에 의해 생성된 me 객체는 Object.prototype의 메서드인 hasOwnProperty를 호출 가능
  - me 객체는 Person.prototype뿐 아니라 Object.prototype도 상속받았음을 의미‼️
- me 객체의 프로토타입은 Person.prototype
  ```jsx
  Object.getPrototypeOf(me) === Person.prototype; // true
  ```
- Person.prototype의 프로토타입은 Object.prototype
  - 프로토타입의 프로토타입은 언제나 `Object.prototype`
  ```jsx
  Object.getPrototypeOf(Person.prototype) === Object.prototype; // true
  ```
  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/c8982ef5-451e-4a2f-8088-d5f4253845c5/image.png)
  - 자바스크립트 객체의 프로퍼티에 접근 시 해당 객체에 접근하려는 프로퍼티가 없다면 → [[Prototype]] 내부 슬롯 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차 검색 ⇒ 프로토타입 체인
    - **프로토타입 체인**: 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
- `me.hasOwnProperty('name')` 호출 시 JS 엔진의 메서드 검색 과정

  ```jsx
  // 프로토타입 체인에 따라 메서드를 검색해 사용
  me.hasOwnProperty('name');
  ```

  1. 먼저 `hasOwnProperty` 메서드를 호출한 me 객체에서 메서드 검색 → me 객체에 해당 메서드 존재 X → 프로토타입 체인 따라 이동해 메서드 검색
  2. `Person.prototype` 에도 `hasOwnProperty` 메서드 X → 프로토타입 체인 따라 상위 프로토타입으로 이동해 메서드 검색
  3. `Object.prototype` 에는 메서드가 존재 → 자바스크립트 엔진은 `Object.prototype.hasOwnProperty` 메서드 호출 → 메서드의 this에는 me 객체가 바인딩 됨

     ```jsx
     // this로 사용할 me 객체를 전달하며 Object.prototype.hasOwnProperty()를 호출
     Object.prototype.hasOwnProperty.call(me, 'name');
     ```

     - **call 메서드**: this로 사용할 객체를 전달하면서 함수를 호출 → 22.2.4절 참고

### 프로토타입 체인의 종점

- 프로토타입 체인의 최상위에 위치하는 객체는 언제나 `Object.prototype` ⇒ 프로토타입 체인의 종점
  - 따라서 모든 객체는 `Object.prototype` 을 상속 받음
  - 최상위 프로토타입의 [[Ptototype]] 내부 슬롯의 값은 null
- 프로토타입 체인 종점에서 프로퍼티를 검색할 수 없는 경우 에러 발생 없이 undefined를 반환

### 프로토타입 체인과 스코프 체인

- JS 엔진은 프로토타입 체인을 따라 프로퍼티/메서드를 검색 ⇒ 객체간 상속 관계로 이뤄진 프로토타입의 계층적 구조에서 객체의 프로퍼티를 검색
  - **프로토타입 체인**: 상속과 프로퍼티 검색을 위한 메커니즘
- 스코프 체인으로 식별자를 검색 ⇒ JS 엔진은 함수의 중첩 관계로 이뤄진 스코프의 계층적 구조에서 식별자를 검색
  - **스코프 체인** ⇒ 식별자 검색을 위한 메커니즘
  - 위 예제인 `me.hasOwnProperty('name');` 의 경우 먼저 스코프 체인에서 me 식별자를 검색 → 전역 선언되었으므로 전역 스코프에서 검색됨 → me 객체의 프로토타입에서 메서드를 검색

⇒ ✅ 스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용된다.

# 19.8 오버라이딩과 프로퍼티 섀도잉

```jsx
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };

  // 생성자 함수를 반환
  return Person;
})();

const me = new Person('Lee');

// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is Lee
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/673ee631-a234-46dd-93ed-3a126ddc9329/image.png)

- **프로토타입 프로퍼티**: 프로토타입이 소유한 프로퍼티
- **인스턴스 프로퍼티**: 인스턴스가 소유한 프로퍼티

### 프로토타입 프로퍼티와 같은 이름을 프로퍼티 인스턴스에 추가하면?

- 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색해 인스턴스 프로퍼티로 추가 → 기존 프로토타입 프로퍼티를 덮어쓰지 않는다.
- 인스턴스 메서드는 프로토타입 메서드를 오버라이딩하고 프로토타입 메서드는 가려진다. ⇒ 프로퍼티 섀도잉

### 프로퍼티 섀도잉

- 상속 관계에 의해 프로퍼티가 가려지는 현상

### 프로퍼티 삭제

```jsx
// 인스턴스 메서드 삭제
delete me.sayHello;

// 인스턴스에 sayHello 메서드가 없으므로 프로토타입 메서드가 호출
me.sayHello(); // Hi! My name is Lee
```

```jsx
// 프로토타입 체인을 통해 프로토타입 메서드 삭제 X
delete me.sayHello();

// 프로토타입 메서드 호출
me.sayHello(); // Hi! My name is Lee
```

- 하위 객체를 통해 프로토타입의 프로퍼티 변경 or 삭제는 불가⚠️
  - 하위 객체를 통해 프로토타입에 get 액세스는 허용, set 액세스는 허용X
- ✅ 프로토타입 프로퍼티를 변경 또는 삭제하려면 프로토타입에 직접 접근해야 함

```jsx
// 프로토타입 메서드 변경
Person.prototype.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

me.sayHello(); // Hey! My name is Lee

// 프로토타입 메서드 삭제
delete Person.prototype.sayHello;
me.sayHello(); // TypeError: me.sayHello is not a function
```

# 19.9 프로토타입의 교체

- 프로토타입은 임의의 다른 객체로 변경 가능
  - 부모 객체인 프로토타입을 동적으로 변경할 수 있음을 의미
  - 이러한 특징으로 객체 간의 상속 관계를 동적으로 변경할 수 있음
- 프로토타입은 생성자 함수 or 인스턴스에 의해 교체 가능

## 19.9.1 생성자 함수에 의한 프로토타입의 교체

```jsx
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    },
  };

  return Person;
})();

const me = new Person('Lee');

// constructor 프로퍼티와 생성자 함수간의 연결 파괴
console.log(me.constructor === Person); // false
console.log(me.constructor === Object); // true
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/bbc73fd3-797b-42f5-b49d-caad8f3a0317/image.png)

- 위 예제에선 Person.prototype에 객체 리터럴을 할당 ⇒ Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것
  - 프로토타입으로 교체한 객체 리터럴엔 constructor 프로퍼티 X ⇒ me 객체의 생성자 함수 검색 시 Person이 아닌 Object가 나타남
  - constructor 프로퍼티는 JS 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티
  - 프로토타입 교체 시 constructor 프로퍼티와 생성자 함수 간 연결이 파괴됨

### 파괴된 constructor 프로퍼티와 생성자 함수 연결 되살리기

- 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가해 되살리기 가능

```jsx
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
    constructor: Person,
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    },
  };

  return Person;
})();

const me = new Person('Lee');

// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person); // true
console.log(me.constructor === Object); // false
```

## 19.9.2 인스턴스에 의한 프로토타입의 교체

- 프로토타입은 생성자 함수의 prototype 프로퍼티뿐 아니라 인스턴스의 **proto** 접근자 프로퍼티(또는 Object.getPrototypeOf 메서드)를 통해 접근 가능
  - 또한 인스턴스의 **proto** 접근자 프로퍼티(또는 Object.setPrototypeOf 메서드)로 프로토타입 교체가 가능
- 생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩하는 것 ⇒ **_미래에 생성할 인스턴스_**의 프로토타입을 교체하는 것이다.
- **proto** 접근자 프로퍼티를 통해 프로토타입을 교체하는 것 ⇒ **_이미 생성된 객체_**의 프로토타입을 교체하는 것

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  },
};

// ① me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작한다.
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/e0de8502-8f3d-4fe8-9f4c-122a4fbc94c6/image.png)

- 위 예제에선 me 객체의 프로토타입을 parent 객체로 교체함
  - 프로토타입으로 교체한 객체에 constructor 프로퍼티 X → constructor 프로퍼티와 생성자 함수간 연결이 파괴
  - constructor 프로퍼티로 me 객체의 생성자 함수 검색 시 Person이 아닌 Object가 나타남
  ```jsx
  // 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.
  console.log(me.constructor === Person); // false
  // 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.
  console.log(me.constructor === Object); // true
  ```

### 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체의 차이

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/10ff2c6c-20ce-455b-875b-d129c4a69cc4/image.png)

- 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티 추가 + 생성자 함수의 prototype 프로퍼티 재설정해 파괴된 연결 되살리기

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {
  // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
  constructor: Person,
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  },
};

// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결을 설정
Person.prototype = parent;

// me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작한다.
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee

// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person); // true
console.log(me.constructor === Object); // false

// 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다.
console.log(Person.prototype === Object.getPrototypeOf(me)); // true
```

- 프로토타입 교체를 통해 객체 간 상속 관계를 동적으로 변경하는 것은 번거롭다. ⇒ 프로토타입을 직접 교체하지 않도록 하자.
  - 상속 관계를 인위적으로 설정하려면 직접 상속이 더 편리하고 안전하다.
  - ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계 구현이 가능하다.

# 19.10 instanceof 연산자

- `객체 instanceof 생성자 함수`

  - 만약 우변의 피연산자가 함수가 아닌 경우: TypeError 발생
  - **true로 평가될 때** → \*\*\*\*우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인상에 존재할 때 / 그렇지 않은 경우 false로 평가

  ```jsx
  //생성자 함수
  function Person(name) {
    this.name = name;
  }

  const me = new Person('Cho');

  // Person.prototype과 Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가
  console.log(me instanceof Person); // true
  console.log(me instanceof Object); // true
  ```

### 프로토타입 교체로 연산자의 동작 이해하기

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Cho');

// 프로토타입으로 교체할 객체
const parent = {};

// 프로토타입의 교체
Object.setPrototypeOf(me, parent);

// Person 생성자 함수와 parent 객체는 연결되어 있지 않다.
console.log(Person.prototype === parent); // false
console.log(parent.constructor === Person); // false

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하지 않기에 false로 평가된다.
console.log(me instanceof Person); // false
// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```

- me 객체는 프로토타입이 교체되며 프로토타입과 생성자 함수 간의 연결이 파괴
  - 그렇지만 Person 생성자 함수에 의해 생성된 인스턴스
- 근데 왜 me instanceof Person이 false로 평가?
  - Person.prototype이 me 객체의 프로토타입 체인 상에 존재하지 않기 때문
  - true로 평가되려면? 프로토타입으로 교체한 parent 객체를 Person 생성자 함수의 prototype 프로퍼티에 바인딩하기

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {};

// 프로토타입의 교체
Object.setPrototypeOf(me, parent);

// Person 생성자 함수와 parent 객체는 연결되어 있지 않다.
console.log(Person.prototype === parent); // false
console.log(parent.constructor === Person); // false

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하지 않기 때문에 false로 평가된다.
console.log(me instanceof Person); // false

// parent 객체를 Person 생성자 함수의 prototype 프로퍼티에 바인딩한다.
Person.prototype = parent;

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Person); // true

// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```

- `instanceof` 연산자는 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인상에 존재하는지 확인

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/74c29744-7b8d-4b9b-a034-327376a26d60/image.png)

- `me instanceof Person` : me 객체의 프로토타입 체인 상에 Person.prototype에 바인딩된 객체가 존재하는지 확인
- `me instanceof Object` : me 객체의 프로토타입 체인 상에 Object.prototype에 바인딩된 객체가 존재하는지 확인

### `instanceof` 연산자를 함수로 표현해보기

```jsx
function isInstanceof(instance, constructor) {
  // 프로토타입 취득
  const prototype = Object.getPrototypeOf(instance);

  // 재귀 탈출 조건
  // prototype이 null이면 프로토타입 체인의 종점에 다다른 것이다.
  if (prototype === null) return false;

  // 프로토타입이 생성자 함수의 prototype 프로퍼티에 바인딩된 객체라면 true를 반환한다.
  // 그렇지 않다면 재귀 호출로 프로토타입 체인 상의 상위 프로토타입으로 이동하여 확인한다.
  return prototype === constructor.prototype || isInstanceof(prototype, constructor);
}

console.log(isInstanceof(me, Person)); // true
console.log(isInstanceof(me, Object)); // true
console.log(isInstanceof(me, Array)); // false
```

- 생성자 함수에 의해 프로토타입이 교체되어 constructor 프로퍼티와 생성자 함수 간 연결이 파괴되어도 생성자 함수의 prototype 프로퍼티와 프로토타입 간 연결의 파괴는 X ⇒ instanceof는 아무런 영향 X

```jsx
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    },
  };

  return Person;
})();

const me = new Person('Lee');

// constructor 프로퍼티와 생성자 함수 간의 연결은 파괴되어도 instanceof는 아무런 영향을 받지 않는다.
console.log(me.constructor === Person); // false

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Person); // true
// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```

# 19.11 직접 상속

## 19.11.1 `Object.create`에 의한 직접 상속

```jsx
/**
* 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환한다.
* @param {Object} prototype - 생성할 객체의 프로토타입으로 지정할 객체
* @param {Object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체
* @returns {Object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체
*/
Object.create(prototype[, propertiesObject])
```

- `Object.create` : 명시적으로 프로토타입을 지정해 새로운 객체 생성
  - 다른 객체 생성 방식과 동일하게 추상 연산 `OrdinaryObjectCreate` 호출
  - 첫번째 매개변수: 생성할 객체의 프로토타입으로 지정할 객체
  - 두번째 매개변수: 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체
    - `Object.defineProperties` 메서드의 두 번째 인수와 동일하며, 옵션이므로 생략 가능
- 첫번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성

### `Object.create()` 를 이용한 다양한 객체 생성 방식

- `Object.create(null);`
  ```jsx
  // 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.
  // obj → null (프로토타입 체인을 의미)
  const obj = Object.create(null);
  console.log(Object.getPrototypeOf(obj) === null); // true
  // Object.prototype을 상속받지 못한다.
  console.log(obj.toString()); // TypeError: obj.toString is not a function
  ```
- `Object.create(prototype);`
  ```jsx
  // obj → Object.prototype → null
  // obj = {};와 동일하다.
  let obj = Object.create(Object.prototype);
  console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
  ```
- `Object.create(prototype, { ... });`
  ```jsx
  // obj → Object.prototype → null
  // obj = { x: 1 };와 동일하다.
  obj = Object.create(Object.prototype, {
    x: { value: 1, writable: true, enumerable: true, configurable: true },
  });
  /* 위 코드는 다음과 동일하다.
  	 obj = Object.create(Object.prototype);
  	 obj.x = 1; */
  console.log(obj.x); // 1
  console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
  ```
- `Object.create({ ... });`
  ```jsx
  const myProto = { x: 10 };
  // 임의의 객체를 직접 상속받는다.
  // obj → myProto → Object.prototype → null
  obj = Object.create(myProto);
  console.log(obj.x); // 10
  console.log(Object.getPrototypeOf(obj) === myProto); // true
  ```
- `Object.create(생성자 함수의 프로토타입);`

  ```jsx
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // obj → Person.prototype → Object.prototype → null
  // obj = new Person('Lee')와 동일하다.
  obj = Object.create(Person.prototype);
  obj.name = 'Lee';
  console.log(obj.name); // Lee
  console.log(Object.getPrototypeOf(obj) === Person.prototype); // true
  ```

### `Object.create()` 의 장점

- new 연산자 없이 객체 생성 가능
- 프로토타입 지정하며 객체 생성 가능
- 객체 리터럴에 의해 생성된 객체 상속 받기 가능

### Object.prototype의 빌트인 메서드 사용

- 모든 객체의 프로토타입 체인의 종점의 메서드이므로 모든 객체가 상속받아 호출 가능
  - `Object.prototype.hasOwnProperty` , `Object.prototype.isPrototypeOf` 등
- ESLint에선 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것 권장 ❌

  - `Object.create` 메서드로 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문
  - 프로토타입 체인의 종점에 위치하는 객체는 `Object.prototype` 의 빌트인 메서드 사용 불가

  ```jsx
  // 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.
  const obj = Object.create(null);
  obj.a = 1;

  console.log(Object.getPrototypeOf(obj) === null); // true

  // obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.
  console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function
  ```

- 에러 발생 위험 제거를 위해 간접 호출을 권장

```jsx
// 프로토타입이 null인 객체를 생성한다.
const obj = Object.create(null);
obj.a = 1;

// console.log(obj.hasOwnProperty('a')); TypeError: obj.hasOwnProperty is not a function

// Object.prototype의 빌트인 메서드는 객체로 직접 호출하지 않는다.
console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true
```

### `Object.create()` 의 단점

- 두 번째 인자로 프로퍼티를 정의하는 것의 번거로움
  - 객체 생성 이후 프로퍼티 추가도 가능하지만 깔끔한 방법이 아님

## 19.11.2 객체 리터럴 내부에서 **proto**에 의한 직접 상속

- ES6에선 객체 리터럴 내부에서 **proto** 접근자 프로퍼티로 직접 상속 구현 가능

```jsx
const myProto = { x: 10 };

// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.
const obj = {
  y: 20,
  // 객체를 직접 상속받는다.
  // obj → myProto → Object.prototype → null
  __proto__: myProto,
};
/* 위 코드는 아래와 동일하다.
const obj = Object.create(myProto, {
  y: { value: 20, writable: true, enumerable: true, configurable: true }
});
*/

console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```

# 19.12 정적 프로퍼티/메서드

- **정적 프로퍼티/메서드**: 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출 가능한 프로퍼티/메서드

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

// 정적 프로퍼티
Person.staticProp = 'static prop';

// 정적 메서드
Person.staticMethod = function () {
  console.log('staticMethod');
};

const me = new Person('Lee');

// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.
Person.staticMethod(); // staticMethod

// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.
// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.
me.staticMethod(); // TypeError: me.staticMethod is not a function
```

- Person 생성자 함수는 객체이므로 자신의 프로퍼티/메서드 소유 가능
  - Person 생성자 함수 객체가 소유한 프로퍼티/메서드 ⇒ 정적 프로퍼티/메서드
- 생성자 함수가 생성한 **인스턴스로 참조/호출 불가**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/d8c98389-4642-43a3-a664-dca6104649bd/image.png)

- 생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메서드에 접근 가능
- 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메서드가 아님 → **인스턴스로 접근 불가**

```jsx
// Object.create는 정적 메서드다.
const obj = Object.create({ name: 'Cho'; });

// Object.prototype.hasOwnProperty는 프로토타입 메서드다.
obj.hasOwnProperty('name'); // → false
```

- `Object.create` : Object 생성자 함수의 정적 메서드로 인스턴스로 호출 불가
- `Object.prototype.hasOwnProperty` : 모든 객체의 프로토타입 체인의 종점인 Object.prototype의 메서드로 모든 객체가 호출 가능

```jsx
function Foo() {}

// 프로토타입 메서드
// this를 참조하지 않는 프로토타입 메소드는 정적 메서드로 변경해도 동일한 효과를 얻을 수 있다.
Foo.prototype.x = function () {
  console.log('x');
};

const foo = new Foo();
// 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 한다.
foo.x(); // x

// 정적 메서드
Foo.x = function () {
  console.log('x');
};

// 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.
Foo.x(); // x
```

- 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않는다면 정적 메서드로 변경 가능
  - 인스턴스가 호출한 인스턴스/프로토타입 메서드 내에서 this는 인스턴스를 가리킴
  - 메서드 내에서 인스턴스의 참조가 불필요하다면 정적 메서드로 변경해도 동작 ⇒ 정적 메서드는 인스턴스를 생성하지 않아도 호출 가능하니까!

### 프로퍼티/메서드 구별 표기법

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7e162375-4776-445e-8305-a21808b1a0e7/955904f4-f9cc-4bb4-9abc-4b81b228c677/image.png)

- 프로토타입 프로퍼티/메서드 표기 시 prototype을 #으로 표기하는 경우도 있다.
  - `Object.prototype.isPrototypeOf` === `Object#isPrototypeOf`

# 19.13 프로퍼티 존재 확인

## 19.13.1 `in` 연산자

- 객체 내에 특정 프로퍼티가 존재하는지 여부 확인

```jsx
/* key: 프로퍼티 키를 나타내는 문자열
	 Object: 객체로 평가되는 표현식 */
key in object;
```

```jsx
const person = {
  name: 'Cho',
  address: 'Seoul',
};

// person 객체에 name 프로퍼티가 존재한다.
console.log('name' in person); // true
// person 객체에 address 프로퍼티가 존재한다.
console.log('address' in person); // true
// person 객체에 age 프로퍼티가 존재하지 않는다.
console.log('age' in person); // false
```

- in 연산자는 확인 대상 객체의 프로퍼티뿐 아니라 확인 대상 객체(ex:Person 객체)가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의 필요
  - `console.log('toString' in person);` 의 결과가 true인 이유
  - person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문 (toString은 Object.prototype의 메서드)

### `Reflect.has` 메서드

```jsx
const person = { name: 'Lee' };

console.log(Reflect.has(person, 'name')); // true
console.log(Reflect.has(person, 'toString')); // true
```

- in 연산자와 동일하게 동작하며 대신 사용할 수 있는 메서드
  - ES6에서 도입된 메서드

## 19.13.2 `Object.prototype.hasOwnProperty` 메서드

```jsx
console.log(person.hasOwnProperty('name')); // true
console.log(person.hasOwnProperty('age')); // false
console.log(person.hasOwnProperty('toString')); // false
```

- 객체에 특정 프로퍼티가 존재하는지 확인할 수 있는 또 다른 방법
- ✅ 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환
  - 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환

# 19.14 프로퍼티 열거

## 19.14.1 `fon...in` 문

- 객체의 모든 프로퍼티를 순회하며 열거할 때 사용 ⇒ `for (변수 선언문 in 객체) { ... }`
  - 객체 자신의 고유 프로퍼티뿐 아니라 상속받은 프로퍼티도 열거

```jsx
const person = {
  name: 'Cho',
  address: 'Seoul',
};

// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.
for (const key in person) {
  console.log(key + ': ' + person[key]);
}
// name: Cho
// address: Seoul
```

- 객체의 프로퍼티 개수만큼 순회하며 `for...in` 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당
- `in` 연산자처럼 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다.
  - 하지만 toString과 같은 `Object.prototype` 의 프로퍼티가 열거되진 않는다. ⇒ 열거할 수 없도록 정의된 프로퍼티라서([[Enumerable]]값이 false)
- `for...in`문은 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중, 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티(열거 가능한 프로퍼티)를 순회하며 열거

```jsx
const person = {
  name: 'Cho',
  address: 'Seoul',
  __proto__: { age: 22 },
};

for (const key in person) {
  console.log(key + ': ' + person[key]);
}

// name: Cho
// address: Seoul
// age: 22
```

- 프로퍼티 키가 심벌인 프로퍼티는 열거 ❌

```jsx
const sym = Symbol();
const obj = {
  a: 1,
  [sym]: 10,
};

for (const key in obj) {
  console.log(key + ': ' + obj[key]);
}
// a: 1
```

### 상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티만 열거하는 법

- `Object.prototype.hasOwnProperty` 메서드 활용해 객체 자신의 프로퍼티인지 확인하기

```jsx
const person = {
  name: 'Cho',
  address: 'Seoul',
  __proto__: { age: 22 },
};

for (const key in person) {
  // 객체 자신의 프로퍼티인지 확인한다.
  if (!person.hasOwnProperty(key)) continue;
  console.log(key + ': ' + person[key]);
}
// name: Cho
// address: Seoul
```

- `for...in` 문은 기본적으로 프로퍼티 열거 시 순서 보장 X

  - 다만 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실 문자열)인 프로퍼티 키에 대해서는 정렬 실시

  ```jsx
  const obj = {
    2: 2,
    3: 3,
    1: 1,
    b: 'b',
    a: 'a',
  };

  for (const key in obj) {
    if (!obj.hasOwnProperty(key)) continue;
    console.log(key + ': ' + obj[key]);
  }

  /*
  1: 1
  2: 2
  3: 3
  b: b
  a: a
  */
  ```

⇒ 배열에는 일반적인 for 문이나 for…of문 혹은 forEach()를 사용하길 권장 (배열도 객체라 프로퍼티와 상속받은 프로퍼티가 포함 가능함을 기억하자)

```jsx
const arr = [1, 2, 3];
arr.x = 10; // 배열도 객체이므로 프로퍼티를 가질 수 있다.

for (const i in arr) {
  // 프로퍼티 x도 출력된다.
  console.log(arr[i]); // 1 2 3 10
}

// arr.length는9 3이다.
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3
}

// forEach 메서드는 요소가 아닌 프로퍼티는 제외한다.
arr.forEach((v) => console.log(v)); // 1 2 3

// for...of는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다.
for (const value of arr) {
  console.log(value); // 1 2 3
}
```

## 19.14.2 `Object.keys/values/entries` 메서드

- 객체 자신의 고유 프로퍼티만 열거하기 위해서 더 효과적인 방법

### `Object.keys` 메서드

- 객체 자신의 **열거 가능한 프로퍼티 키**를 배열로 반환

```jsx
const person = {
  name: 'Cho',
  address: 'Seoul',
  __proto__: { age: 22 },
};

console.log(Object.keys(person)); // ["name", "address"]
```

### `Object.vlaues` 메서드

- 객체 자신의 **열거 가능한 프로퍼티 값**을 배열로 반환
  - ES8에서 도입

```jsx
console.log(Object.values(person)); // ["Cho", "Seoul"]
```

### `Object.entries` 메서드

- 객체 자신의 **열거 가능한 프로퍼티 키와 값의 쌍의 배열**을 배열에 담아 반환
  - ES8에서 도입

```jsx
console.log(Object.entries(person)); // [["name", "Cho"], ["address", "Seoul"]]

Object.entries(person).forEach(([key, value]) => console.log(key, value));
/*
name Cho
address Seoul
*/
```
