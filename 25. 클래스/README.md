# **핵심 개념 간략 정리:** 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 자바스크립트 → 프로토타입 기반 객체지향 언어
  - 다른 객체지향 언어와 달리 클래스 없이 생성자함수와 프로토타입으로 객체지향 언어의 상속 구현 가능
  - ⇒ 자바스크립트 진입 장벽 상승의 원인
- 자바스크립트 ES6에서 클래스 도입
  - 클래스 기반 객체지향 언어와 매우 흡사한 새로운 객체 생성 메커니즘
- 생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현한 점에서 매우 유사
  - But, 클래스는 상대적으로 더 견고하고 명료함
- 클래스 ⇒ 단순한 프로토타입 기반 객체 생성 패턴의 문법적 설탕이 아닌 새로운 객체 생성 메커니즘✔️

## 25.2 클래스 정의

- `class` 키워드를 사용해 정의
  - 함수처럼 표현식으로도 정의 가능하지만 일반적인 방식은 아님
- 표현식으로 정의할 수 있음은 곧, 클래스가 일급객체(함수)임을 의미
- 클래스 몸체에서 정의할 수 있는 메서드
  - `constructor` , 프로토타입 메서드, 정적 메서드
- 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사한 편

## 25.3 클래스 호이스팅

- 클래스 선언문으로 정의한 클래스
  - 함수 선언문처럼 런타임 이전에 먼저 평가 → 함수 객체 생성
  - 이때 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수
- 클래스도 변수 선언, 함수 정의처럼 호이스팅 발생
  - But, 클래스는 클래스 정의 이전에 참조 불가 (→ 호이스팅이 발생하지 않는 것처럼 동작)
  - `let` , `const` 키워드로 선언한 변수처럼 클래스 선언문 이전엔 TDZ에 빠지게 되기 때문

## 25.4 인스턴스 생성

- 클래스는 생성자 함수, `new` 연산자와 함께 호출되어 인스턴스를 생성
  - 인스턴스를 생성하는 것이 클래스의 유일한 존재 이유✨
  - 클래스는 반드시 `new` 연산자와 함께 호출해야 함

## 25.5 메서드

### 25.5.1 `constructor`

- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
  - 단순한 메서드로 해석되는 것이 아닌, 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
- 클래스 정의가 평가되면 `constructor` 의 기술된 동작을 하는 함수 객체가 생성 됨
- `constructor` 의 특징
  - 클래스 내에 최대 한 개만 존재해야 함
  - 생략 가능
  - 생략 시 빈 `constructor` 가 암묵적으로 정의됨
  - 프로퍼티가 추가된 상태로 초기화된 인스턴스를 생성하려면 내부 this에 인스턴스 프로퍼티를 추가
  - 인스턴스 생성 시 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 `constructor` 에 매개변수를 선언해 인스턴스 생성 시 초기값을 전달
- `constructor` 내부에는 별도의 반환문을 명시하지 말 것
  - 기존 생성자 함수와 동일함

### 25.5.2 프로토타입 메서드

- 클래스 몸체에서 정의한 메서드 → 기본적으로 프로토타입 메서드
  - 생성자 함수에선 명시적으로 프로토타입 메서드를 추가해야 함
- 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨
  - 생성자 함수도 마찬가지
  - 인스턴스는 프로토타입 메서드를 상속받아 사용 가능
  - ✔️ 클래스와 생성자 함수는 모두 인스턴스를 생성하는 생성자 함수 & 프로토타입 기반의 객체 생성 메커니즘

### 25.5.3 정적 메서드

- 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
- 클래스에서 정적 메서드 생성 → `static` 키워드 붙이기
  - 생성자 함수에서 정적 메서드 생성 → 명시적으로 `생성자함수명.정적메서드명` 식으로 추가
- 정적 메서드는 클래스에 바인딩된 메서드가 됨
  - 클래스는 별다른 생성 과정 필요 없이 클래스 정의가 평가되는 시점에 함수 객체가 됨
  - ⇒ 정적 메서드는 클래스 정의 이후 인스턴스 생성없이 호출 가능
  - 인스턴스 없이 클래스 자체로 호출해야 함
- 인스턴스로는 호출 불가능
  - 정적 메서드가 바인딩된 클래스가 인스턴스의 프로토타입 체인상에 존재하지 않기 때문

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

- 정적 메서드와 프로토타입 메서드는 속한 프로토타입 체인이 다름
  - 두 메서드 내부의 this 바인딩이 다름
    - 프로토타입 메서드 내부의 this → 프로토타입 메서드를 호출한 인스턴스
    - 정적 메서드 내부의 this → 클래스
  - ✅ 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 없다면 정적 메서드로 정의하는 것이 좋다.
- 정적메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출함
- 정적 메서드는 인스턴스 프로퍼티 참조 불가, 프로토타입 메서드는 인스턴스 프로퍼티 참조 가능
- 표준 빌트인 객체도 다양한 정적 메서드를 가짐
  - 정적 메서드 → 애플리케이션 전역에서 사용할 유틸리티 함수
  - 👍 클래스나 생성자 함수를 하나의 네임스페이스로 사용해 정적 메서드를 모아두면 이름 충돌 가능성 감소, 관련 함수 구조화 효과 발생
  - ✔︎ 정적 메서드는 유틸리티 함수를 메서드로 구조화할 때 유용

### 25.5.5 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용
2. 객체 리터럴과는 다르게 클래스 메서드 정의 시 콤마 필요 X
3. 암묵적으로 strict mode로 실행
4. `for ... in` 문, `Object.keys` 메서드 등으로 열거 불가
5. 내부 메서드 `[[Construct]]` 를 갖지 않는 `non-constructor`

## 25.6 클래스의 인스턴스 생성 과정

### 1. 인스턴스 생성과 this 바인딩

- `new` 연산자와 함께 클래스 호출 시 `constructor` 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성됨
  - 이 빈 객체가 클래스가 생성한 (미완성) 인스턴스
- 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 `prototype` 프로퍼티가 가리키는 객체가 설정됨
- 암묵적으로 생성된 빈 객체(인스턴스)는 `constructor` 내부 this에 바인딩됨

### 2. 인스턴스 초기화

- `constructor` 내부 코드가 실행되어 this에 바인딩된 인스턴스를 초기화함
  - this에 바인딩된 인스턴스에 프로퍼티 추가 → `constructor` 가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값 초기화
- `constructor` 가 생략된 경우 이 과정도 생략

### 3. 인스턴스 반환

- 클래스의 모든 처리가 끝나면 “완성된 인스턴스가 바인딩된 this”가 암묵적으로 반환

## 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티

- `constructor` 내부에서 정의
- `constructor` 내부 코드가 실행되기 이전에 `constructor` 내부의 `this`에는 클래스가 암묵적으로 생성한 빈 객체가 바인딩되어 있음
- `constructor` 내부에서 `this`에 추가한 프로퍼티는 언제나 클래스가 생성한 인스턴스의 프로퍼티

### 25.7.2 접근자 프로퍼티

- getter, setter 함수로 구성, 클래스에서도 사용 가능
  - **getter** → 반드시 무언가를 반환해야 함
  - **setter** → 반드시 매개변수가 있어야 함
- 프로토타입의 프로퍼티 메서드로 들어감

### 25.7.3 클래스 필드 정의 제안

```jsx
// 클래스 필드 예제
class Person {
  name = 'Jiyu'; // 클래스 필드에 인스턴스 변수 선언
}

const person = new Person(); // Person {name: "Ahn"}

// 위의 코드와 동일하게 동작
class Person {
  constructor() {
    this.name = 'Jiyu';
  }
}
```

- 인스턴스 프로퍼티를 정의하는 방식
  - `constructor`에서 인스턴스 프로퍼티 정의
    - 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 있는 or 없는 경우 모두 사용 가능
  - 클래스 필드 정의
    - 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 없는 경우에 사용

### 25.7.4 `private` 필드 정의 제안

- 자바스크립트는 캡슐화를 완전히 지원 X → 언제나 **public**
- 최신 브라우저와 최신 Node.js는 private 필드를 정의할 수 있는 새로운 표준 사양이 제안됨
- private 필드는 반드시 클래스 몸체에 정의해야 하며, `constructor` 에 정의하면 SyntaxError 발생
- 타입스크립트에서는 클래스 기반의 객체지향 언어가 지원하는 접근 제한자인 public, private, protected를 모두 지원하며, 의미 또한 기본적으로 동일함

```jsx
class Person {
  #name = ''; // private 필드의 선두에는 #을 붙임.

  consturctor(name) {
    this.#name = name; // private 필드 참조시에도 # 붙임
  }

  get name() {
    return this.#name.trim(); // 접근자 프로퍼티를 통해 간접적으로 접근 가능
  }
}

const me = new Person('Ahn');

console.log(me.#name); // SyntaxError
console.log(me.name); // Ahn
```

### 25.7.5 `static` 필드 정의 제안

- 기존 클래스에서는 static 키워드를 사용하여 정적 메서드 정의는 가능했으나, 정적 필드 정의는 불가능
- 최신 브라우저와 최신 Node.js에서 static private 필드, static private 메서드를 정의할 수 있는 새로운 표준 사양이 제안되어 있음

```jsx
class MyMath {
  // static public 필드 정의
  static PI = 22 / 7;

  // static private 필드 정의
  static #num = 10;

  // static 메서드
  static increment() {
    return ++MyMath.#num;
  }
}

console.log(MyMath.PI); // 3.1425857142857143
console.log(MyMath.increment()); // 11
```

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

- 기존 클래스를 상속받아 새로운 클래스를 확장(`extends`)하여 정의하는 것
- 코드 재사용 관점에서 매우 유용
- 클래스는 상속을 통해 다른 클래스로 확장할 수 있는 문법인 `extends` 키워드가 기본적으로 제공됨

### 25.8.2 `extends` 키워드

- `extends` 키워드를 사용하여 상속받을 클래스 정의
- 수퍼클래스와 서브클래스 간의 상속 관계를 설정
- 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성하므로 프로토타입 메서드, 정적 메서드 모두 상속 가능

### 25.8.3 동적 상속

- `extends` 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스 확장도 가능
  - `extends` 키워드 앞에 반드시 클래스가 와야함
  - `extends` 키워드 다음에는 클래스뿐만이 아닌 `[[Construct]]` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식 사용 가능

```jsx
function Base1 {}

class Base2 {}

let condition = true;

class Derived extends (condition ? Base1 : Base2) {}

const derived = new Derived();
console.log(derived); // Derived {}
```

### 25.8.4 서브클래스의 `constructor`

- 클래스에서 `constructor` 생략시 비어있는 `constructor`가 암묵적으로 정의됨
- 서브클래스에서 `constructor`를 생략하면 클래스와 다음과 같은 `constructor` 가 암묵적으로 정의됨
  ```jsx
  constructor(...args) { super(...args); };
  ```

### 25.8.5 `super` 키워드

- 함수처럼 호출할 수도 있고 `this`와 같이 식별자처럼 참조할 수 있는 특수한 키워드
- 동작 방식
  - `super`를 호출하면 수퍼클래스의 `constructor` 호출
    - 인스턴스 초기화를 위해 전달한 인수는 수퍼클래스와 서브클래스에 배분되고 상속 관계의 두 클래스는 서로 협력하여 인스턴스를 생성
  - `super`를 참조하면 수퍼클래스의 메서드를 호출
    - ES6의 메서드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 가지며, 이를 가진 함수만이 `super` 참조 가능

### 25.8.6 상속 클래스의 인스턴스 생성 과정

1. 수퍼클래스의 `super` 호출
2. 수퍼클래스의 인스턴스 생성과 `this` 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 `constructor` 로의 복귀와 `this` 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

### 25.8.7 표준 빌트인 생성자 함수 확장

- `extends` 키워드 다음에는 클래스뿐만이 아닌 `[[Construct]]` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식 사용 가능
- String, Number, Array와 같은 표준 빌트인 객체도 `[[Construct]]` 내부 메서드를 갖는 생성자 함수이므로 `extends` 키워드 사용하여 확장 가능
  - map, filter와 같이 새로운 배열을 반환하는 메서드는 서브클래스의 인스턴스를 반환 → 서브클래스의 메서드와 메서드 체이닝 가능
