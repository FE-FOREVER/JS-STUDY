### 🔍 이 장의 keyword!

> 객체, 프로퍼티, 메서드, 객체 리터럴, 식별자 네이밍 규칙, 키-값, 프로퍼티 접근, 프로퍼티/메서드 축약 표현, 계산된 프로퍼티 이름

## 목차

1. [객체란?](#101-객체란)
2. [객체 리터럴에 의한 객체 생성](#102-객체-리터럴에-의한-객체-생성)
3. [프로퍼티](#103-프로퍼티)
4. [메서드](#104-메서드)
5. [프로퍼티 접근](#105-프로퍼티-접근)
6. [프로퍼티 값 갱신](#106-프로퍼티-값-갱신)
7. [프로퍼티 동적 생성](#107-프로퍼티-동적-생성)
8. [프로퍼티 삭제](#108-프로퍼티-삭제)
9. [ES6에서 추가된 객체 리터럴의 확장 기능](#109-es6에서-추가된-객체-리터럴의-확장-기능)

# 10.1 객체란?

## 객체

- 0개 이상의 프로퍼티로 구성된 집합
  - 프로퍼티는 key-value로 구성
    
    <img width="400" height="200" alt="객체key-value" src="https://github.com/user-attachments/assets/5074409e-e0b6-4e49-867d-8e3657fe824b" />

  - 프로퍼티와 메서드로 구성된 집합체
  
    <img width="500" height="250" alt="객체프로퍼티-메서드" src="https://github.com/user-attachments/assets/feb3bfdc-e581-4bf1-8a8b-466638cafe63" />
    
## 자바스크립트와 객체

- JS는 객체기반 프로그래밍 언어
  - 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등) 모두 객체 → JS를 구성하는 거의 모든 것이 객체다!
  - 객체타입은 복합적인 자료구조!
    - 다양한 타입의 값(원시 값 or 다른 객체)을 하나의 단위로 구성
- JS에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용 가능
  - 따라서 JS에선 함수도 프로퍼티 값으로 사용 가능하다. → why? JS에선 함수가 곧 일급 “객체”
    - 단, 프로퍼티 값으로 사용되는 함수는 “메소드”라고 부른다.
- 객체는 프로퍼티와 메서드로 구성된 집합체로 상태와 동작을 하나의 단위로 구조화 가능
  - 프로퍼티: 객체의 상태를 나태나는 값(data)
  - 메서드: 프로퍼티를 참조 및 조작할 수 있는 동작(behavior)

# 10.2 객체 리터럴에 의한 객체 생성

## 자바스크립트의 다양한 객체 생성 방법

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6 도입)

⇒ 이 중 가장 일반적이고 간단한 객체 생성 법은 **객체 리터럴!**
객체 리터럴을 제외한 다른 방식은 모두 함수를 사용해 객체 생성

## 객체 리터럴

- 객체를 생성하기 위한 표기법
  - JS의 유연 + 강력함 대표하는 객체 생성 방식
- 중괄호 내에 0개 이상의 프로퍼티 정의
- 프로퍼티를 포함시켜 객체 생성 + 프로퍼티 정의 or 객체 생성 이후 프로퍼티 동적 추가 가능
- JS 엔진은 변수에 할당되는 시점에 객체 리터럴을 해석해 객체를 생성
  - 이 두 부분도 코드 블럭 넣기
- 중괄호 내 프로퍼티 정의 X → 빈 객체 생성
  - 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는 데 주의 → 이 경우에는 닫는 중괄호 뒤에 세미콜론 표기

# 10.3 프로퍼티

- 키와 값으로 구분
- 프로퍼티의 집합이 객체
  - 프로퍼티 나열 시 쉼표로 구분 (마지막 프로퍼티 뒤 쉼표는 사용X가 관례, but 사용해도 무관)
- 프로퍼티 키와 값으로 사용할 수 있는 값은 아래와 같다.
  - 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 or 심벌 값
  - 프로퍼티 값: JS에서 사용할 수 있는 모든 값
- 프로퍼티 키?
  - 프로퍼티 값에 접근할 수 있는 이름(식별자) → 반드시 식별자 네이밍 규칙 따를 필요X
    - 네이밍 규칙을 따르지 않는 경우 명시, 사용 방식에 차이가 있다.
  - 일반적으로 심벌 값보다는 문자열을 사용
    - 따라서 키 이름을 따옴표로 묶어야 하지만, 식별자 네이밍 규칙을 준수하는 이름은 따옴표 생략 가능!
    - ⚠️ 식별자 네이밍 규칙을 따르지 않는다면 반드시 따옴표 사용 필요

## 프로퍼티 키 관련 다양한 예제

### 식별자 네이밍 규칙 준수하지 않는 프로퍼티 키

→ 따옴표로 감싸줄 것

```jsx
var person = {
	firstName: 'Min-ji', // 식별자 네이밍 규칙을 준수하는 프로퍼티 키 (따옴표 생략 가능)
	'last-name': 'Cho' . // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키 (따옴표 생략 불가)
};
```

```jsx
var person = {
	firstName: 'Min-ji',
	last-name: 'Cho' // `-` 연산자가 있는 표현식으로 해석해 last - name이 되고, 구문에러 발생
};
```

### 프로퍼티 키 동적 생성

→ 표현식을 대괄호로 감싸줄 것

```jsx
var obj = {};
var key = 'hello';

// ES5: 프로퍼티 키 동적 생성 문법
obj[key] = 'world';
// ES6: 계산된 프로퍼티 이름 문법
var obj2 = { [key]: 'world' };

console.log(obj); // {hello: "world"}
console.log(obj2); // {hello: "world"}
```

### 프로퍼티 키와 빈 문자열

→ 프로퍼티 키에 빈 문자열 사용 시 에러 발생 X, but 키로서의 의미도 X ⇒ 지양할 것

```jsx
var foo = {
  '': '', // 빈 문자열도 프로퍼티 키로 사용 가능
};
```

### 암묵적 타입 변환

→ 문자열 or 심벌 값 외의 값은 암묵적 타입 변환으로 문자열이 된다. 숫자 리터럴의 경우 따옴표 없이 사용되지만, 내부적으로는 문자열로 변환된다.

```jsx
var foo = {
  0: 1,
  1: 2,
  2: 3,
};
```

### 프로퍼티 키와 예약어

→ 예약어를 프로퍼티 키로 사용 가능, but 예상치 못한 에러 발생 가능성이 있기에 권장X

```jsx
var foo = {
  var: '',
  function: '',
};
```

### 중복 프로퍼티 키

→ 중복 선언 시 에러는 발생하지 않고 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.

```jsx
var foo = {
  name: 'Lee',
  name: 'Cho',
};

console.log(foo); // {name: "Cho"}
```

# 10.4 메서드

JS에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용가능하며, 이에 따라 JS에서 일급 객체인 함수도 값으로 사용 가능하다.

프로퍼티 값이 함수일 경우 일반 함수와의 구분을 위해 메서드라고 부른다.

→ 메서드: 객체에 묶여있는 함수 (함수에 대해선 12장에서 자세히 살펴보자!)

```jsx
var circle = {
  radius: 5, // 프로퍼티

  getDiameter: function () {
    return 2 * this.radius; // this는 circle을 가리킨다.
  },
};

console.log(circle.getDiameter()); // 10
```

→ this 키워드? 객체 자신(circle 객체)를 가리키는 참조변수 (22장에서 자세히 살펴보자!)

# 10.5 프로퍼티 접근

## 프로퍼티에 접근하는 두 가지 방식

- 마침표 표기법
  - 마침표 프로퍼티 접근 연산자(`.`)사용
  - `객체로 평가되는 표현식.프로퍼티 키` 형태
- 대괄호 표기법
  - 대괄호 프로퍼티 접근 연산자(`[…]`) 사용
  - `객체로 평가되는 표현식[프로퍼티 키]`

→ 프로퍼티 키가 JS에서 사용 가능한 유효한 이름이면 위 두 방식 모두 사용 가능

```jsx
var person = {
  name: 'Lee',
};

// 마침표 표기법에 의한 프로퍼티 접근
console.log(person.name); // Lee

// 대괄호 표기법에 의한 프로퍼티 접근(반드시 프로퍼티 키를 따옴표로 감싸기)
console.log(person['name']); // Lee

console.log(person[name]); // ReferenceError 발생
```

⚠️ 대괄호 표기법일 땐, 대괄호 내에 프로퍼티 키를 반드시 따옴표로 감싼 문자열 형태여야 한다.

- 만약 따옴표로 감싸지 않은 경우, JS엔진은 이를 식별자로 해석하니 주의 (따라서 변수를 키로 사용하는 경우엔 따옴표 없이 사용 가능)
- 정의되지 않은 식별자의 경우, 위 예시처럼 참조 에러가 발생 (이때 프로퍼티 키와 동일하게 정의된 식별자가 있다면 에러 없이 undefined를 반환)

### 객체에 존재하지 않는 프로퍼티 접근

→ undefined 반환O 참조 에러 발생X 정의되지 않은 키니까!

```jsx
var person = {
  name: 'Lee',
};

console.log(person.age); // undefined
```

### 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키

→ 반드시 **대괄호 표기법 사용 및 따옴표**로 감싸주기!!

but, 숫자로 이뤄진 문자열인 경우 따옴표 생략 가능 (대괄호 표기법은 사용)

### 프로퍼티 키 접근 방식에 따른 다양한 결과

```jsx
var person = {
	'last-name': 'Lee',
	1: 10
};

person.'last-name'; // SyntaxError: Unexpected string
person.last-name; // 브라우저 환경: NaN
									// Node.js 환경: undefined

person[last-name]; // ReferenceError: last is not defined
person['last-name']; // Lee

person.1; // SyntaxError: Unexpected number
person.'1'; // SyntaxError: Unexpected string
person[1]; // 10 : person[1] -> person['1']
person['1']; // 10
```

※ `person.last-name` 의 실행 결과가 차이가 나는 이유

- 자바스크립트 엔진에서는 person.last를 먼저 평가하는데, 이때 person 객체에 last라는 프로퍼티가 존재하지 않기에 `undefined`를 반환한다.
- 다음으로 - 연산자 뒤에 name을 식별자라고 판단하는데 여기서 두 환경의 차이가 발생한다.
- 브라우저 환경: name을 window 객체에 있는 전역변수(`’’`)로 판단하여 `undefined - ''` 에 따라 `NaN` 반환
- Node.js 환경: name이란 식별자 존재 X → `Reference Error` 발생

# 10.6 프로퍼티 값 갱신

→ 이미 존재하는 프로퍼티에 값을 할당할 때 발생

```jsx
var person = {
  name: 'Lee',
};

// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신
person.name = 'Kim';

console.log(person); //{name: "Kim"}
```

# 10.7 프로퍼티 동적 생성

→ 존재하지 않는 프로퍼티에 값을 할당할 때 발생

```jsx
var person = {
  name: 'Lee',
};

/* person 객체에는 age 프로퍼티가 존재 X 
 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당 */
person.age = 20;

console.log(person); //{name: "Lee", age:20}
```

# 10.8 프로퍼티 삭제

→ `delete` 연산자로 프로퍼티 삭제 가능, 존재하지 않는 프로퍼티 삭제 시 _에러 발생X 무시됨!_

```jsx
var person = {
  name: 'Lee',
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티 존재 → delete 연산자로 age 프로퍼티 삭제 가능
delete person.age;

// person 객체에 address 프로퍼티 존재X → delete 연산자로 address 프로퍼티 삭제 X, 에러 발생 X
delete person.address;

console.log(person); // {name: "Lee"}
```

# 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

→ ES6에선 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공!!

## 10.9.1 프로퍼티 축약 표현

프로퍼티의 값이 변수에 할당된 값(식별자 표현식)일 수 있다.

✔︎ ES6에선 프로퍼티 값으로 변수를 사용할 때, 변수 이름과 프로퍼티 키가 동일한 경우 **프로퍼티 키 생략 가능**

### ES5

```jsx
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}
```

### ES6

프로퍼티 축약 표현 사용

```jsx
let x = 1,
  y = 2;

// 프로퍼티 축약 표현
const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

## 10.9.2 계산된 프로퍼티 이름

문자열 or 문자열로 타입 변환 가능한 값으로 평가되는 표현식으로 **프로퍼티 키 동적 생성 가능**
⇒ 반드시 프로퍼티 키로 사용할 **표현식은 대괄호로 묶을 것!**
이 자체를 게산된 프로퍼티 이름이라 한다.

### ES5

객체 리터럴 외부에서 대괄호 표기법 사용

```jsx
var prefix = 'prop';
var i = 0;

var obj = {};

// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### ES6

객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성 가능

```jsx
const prefix = 'prop';
let i = 0;

const obj = {
	[`${prefix}-${++i}`] = i;
	[`${prefix}-${++i}`] = i;
	[`${prefix}-${++i}`] = i;
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

## 10.9.3 메서드 축약 표현

### ES5

메서드 정의 시 프로퍼티 값으로 함수 할당

```jsx
var obj = {
  name: 'Lee',
  sayHi: function () {
    console.log('Hi! ' + this.name);
  },
};
```

### ES6

메서드 정의 시 `function` 키워드 생략한 축약 표현 사용 가능

⚠️ 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작 (26.2절에서 더 알아보자!)

```jsx
var obj = {
  name: 'Lee',
  sayHi() {
    // 메서드 축약 표현
    console.log('Hi! ' + this.name);
  },
};
```
