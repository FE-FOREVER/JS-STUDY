### 🔍 이 장의 keyword!

> 원시 값, 불변성, 데이터 신뢰성, 메모리 공간, 재할당, 값에 의한 전달, 객체, 참조 값, 참조에 의한 전달, 식별자, 변경 가능

## 목차

1. [원시 값](#111-원시-값)
2. [객체](#112-객체)

# 11.1 원시 값

## 자바스크립트의 원시 타입과 객체 타입의 차이

### 원시 타입

- 원시 값: 변경 **불가능**한 값(immutable value)
- 변수 할당 시 변수(확보된 메모리 공간)에 **실제 값이 저장**
- **값**에 의한 전달
  - 원시 값 갖는 변수를 **다른 변수에 할당 시 원본 원시 값이 복사되어 전달**

### 객체 타입

- 객체: 변경 **가능**한 값(mutable value)
- 변수 할당 시 변수에 **참조 값이 저장**
- **참조**에 의한 전달
  - 객체를 가리키는 변수를 **다른 변수에 할당 시 원본의 참조 값이 복사되어 전달**

|                | 원시 타입      | 객체 타입        |
| -------------- | -------------- | ---------------- |
| 값             | 원시 값        | 객체             |
| 변경 여부      | 변경 불가능    | 변경 가능        |
| 변수에 할당 시 | 실제 값 저장   | 참조 값이 저장   |
| 자료 전달 방법 | 값에 의한 전달 | 참조에 의한 전달 |

## 11.1.1 변경 불가능한 값

### 원시 타입의 값(원시 값)

- 읽기 전용 값으로서 변경 불가
  - 변경 불가는 원시 값 자체를 의미하는 것
    - 값은 변수에 저장된 데이터로서 표현식 평가로 생성된 결과
  - 변수는 값 저장을 위해 확보한 메모리 공간 or 메모리 공간 식별 위해 붙인 값
    - 따라서 변수는 언제든지 재할당으로 변수 값을 변경(교체) 가능 → but 상수는 재할당이 금지된 변수!
- 불변의 특성을 가진 원시 값은 **데이터의 신뢰성을 보장!**

### 변수에 원시 값을 재할당

<img alt="변수에원시값재할당" width="800" height="300" src="https://github.com/user-attachments/assets/a5fd9531-29ae-405a-ba21-a444b81ce920" />

- 변수에 할당된 원시 값은 변경 불가능 ⇒ 재할당 시 변수가 참조하던 메모리 공간의 주소가 변경
  - 재할당 시 이전의 원시 값 자체 변경이 아닌 새 메모리 공간을 확보 → 재할당한 원시 값 저장 → 새롭게 재할당한 원시 값을 가리킴의 과정이 발생하는 이유!
- 만약 원시 값이 변경 가능한 값이라면 메모리 공간 주소 변경 필요 X 원시 값 자체 변경하면 그만~

### 불변성

- 원시 값은 불변성을 가지기에 변수에 원시 값이 할당됐다면 **재할당** 이외에 변수 값 변경 불가!
  - 재할당이외에 원시 값인 변수 값 변경 가능하다면? 예기치 않은 변수 값 변경 가능성으로 값의 변경(상태 변경) 추적의 어려움 발생

## 11.1.2 문자열과 불변성

### 문자열과 메모리 공간

- ES 사양에서 문자열 타입은 2바이트
- 문자열은 0개 이상의 문자로 이뤄진 집합 → 몇 개의 문자로 이뤄졌냐에 따라 필요 메모리 공간의 크기 결정
- JS는 C나 JAVA와 달리 원시 타입의 문자열 타입 제공 ⇒ 변경 불가능

### 문자열 원시 값 재할당 시 과정

```jsx
var str = 'Hello';
str = 'world';
```

1. 첫 번째 문 실행 시 문자열 ‘Hello’ 생성 → str은 문자열 ‘Hello’가 저장된 메모리 공간을 가리킴
2. 두 번째 문 실행 시 새로운 문자열 ‘world’를 메모리에 생성 → 식별자 str이 ‘world’의 메모리 공간을 가리킴

⇒ ‘Hello’ & ‘world’ 모두 메모리에 존재하며 식별자 str은 처음에 ‘Hello’를 가리키다가 ‘world’를 가리키도록 변경되는 것

### 유사 배열 객체

- 마치 배열처럼 인덱스로 프로퍼티 값 접근 가능 & length 프로퍼티를 갖는 객체
- 문자열은 유사 배열 객체 & 이터러블 ⇒ 배열과 유사하게 각 문자 접근 가능
  - for문 순회도 가능하다!
  - 원시 값 객체처럼 사용 시 원시 값을 감싸는 래퍼 객체로 자동 변환! (📚21.3)
- 인덱스로 문자에 접근할 수 있으나, 원시 값의 불변성으로 값의 변경은 불가능!!!
  - 변수에 새로운 문자열을 재할당하는 것은 가능! 기존 문자열 변경이 아니기때문

```jsx
var str = 'string';

console.log(str[0]); // s
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING

str[0] = 'S'; // 변경 불가지만, 에러 발생도 X

console.log(str); // string
```

## 11.1.3 값에 의한 전달

```jsx
var score = 80;
var copy = score;
```

- 이때, copy가 가리키는 값은? score의 변수 값으로 평가되는 값 80
  - 새로운 숫자 값 80이 생성되어 copy 변수에 할당
- **값에 의한 전달**
  - 변수에 원시 값을 갖는 다른 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 **복사** 후 전달 ⇒ **서로 다른 메모리 공간에 저장된 별개의 값**을 가리킨다.

<img alt="값에의한전달" width="600" height="300" src="https://github.com/user-attachments/assets/8c2098a1-b598-4b01-b7bd-9b165501fb44" />

```jsx
var score = 80;

var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true → 변수에 할당된 원시 값이 같아서!

// copy와 score 변수의 값은 다른 메모리 공간에 저장된 별개의 값
// score 변수 값 변경해도 copy 변수 값에 영향 X
score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

<img alt="값에의한전달2" width="800" height="300" src="https://github.com/user-attachments/assets/836e73d2-f138-48d6-b6ad-fd5b20990e06" />

- ES사양에선 변수를 통해 메모리를 어떻게 관리하는지 명확한 정의 X 따라서 실제 JS 엔진 구현 제조사에 따라 실제 내부 동작 방식의 미묘한 차이 가능성 ⭕️
- 위에선 변수에 원시 값을 갖는 변수 할당 시 원시 값이 복사되는 것으로 표현했지만, 다른 방식으로 동작할 수도 있다.
  - ex) 변수에 원시 값을 갖는 변수를 할당할 땐, 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수가 재할당 시 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.

### 값에 의한 전달

- ECMAScript 사양에 등장하지 않는 용어
  - 공유에 의한 전달이라고 표현하기도 한다.
  - JS를 위한 용어가 아니기도 하다.
- JS에선 변수에 값이 아닌 메모리 주소가 전달
  - 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기 때문!
  - 식별자의 역할은 기억하고 있는 메모리 공간에 저장된 값에 접근하는 것 ⇒ 메모리 주소에 붙인 이름
  - `var x = 20;` : 숫자 리터럴 20에 의해 생성된 숫자 값 20이 저장된 메모리 공간의 주소를 전달 → x는 메모리 공간에 저장된 숫자 값 20 식별 가능
- `var copy = score;`
  - score는 식별자 표현식으로 숫자 값 80으로 평가되며 두 가지 평가 방식이 가능
  1. 새로운 80 생성(복사) 후 메모리 주소 전달 → 할당 시점 두 변수가 기억하는 메모리 주소가 다르다.
  2. score 변수값 80의 메모리 주소 그대로 전달 → 할당 시점 두 변수가 기억하는 메모리 주소가 같다.
     ⇒ 이렇게 값에 의한 전달도 값이 아닌 메모리 주소를 전달하는 것, 전달된 메모리 주소로 메모리 공간 접근 시 값 참조 가능!
  - 두 가지 평가 방식에서 중요한 점은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 된다. 따라서 어느 한쪽에서 재할당으로 값을 변경해도 서로 간섭 불가!

# 11.2 객체

### 객체?

- 원시 값과 같이 확보해야 할 메모리 공간의 크기 사전 결정 불가
  - 프로퍼티 동적 추가 및 삭제 가능 & 개수와 값의 제약 X
- 복합적인 자료구조로 경우에 따라 크기가 매우 클 수 있다.
  - 객체 생성 및 프로퍼티 접근또한 원시 값과 비교 시 비용이 많이 드는 일
  - 원시 값과 다른 방식으로 동작하도록 설계!

### JS의 객체 관리 방식

- JS의 객체: 프로퍼티 키를 인덱스로 사용하는 해시 테이블
  - 대부분의 JS 엔진은 해시테이블과 유사 but 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체 구현
- JS는 JAVA, C++과 같은 클래스 기반 객체 지향 프로그래밍 언어와 달리 클래스 없이 객체 생성 가능, 동적으로 프로퍼티 및 메서드 추가 가능
  - 사용성면에선 편리하지만, 성능 면에선 상대적으로 생성과 프로퍼티 접근 비용이 더 많이 든다.
  - 이를 해결하기 위해 V8 JS엔진에선 프로퍼티 접근을 위해 동적 탐색 대신 히든 클래스 방식 사용
    - C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장
    - JAVA와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작

## 11.2.1 변경 가능한 값

- 객체(참조) 타입의 값 → 변경 가능한 값

### 변수에 객체를 할당하면?

```jsx
var person = {
  name: 'Lee',
};
```

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면?
  - 참조 값(생성된 객체가 저장된 메모리 공간의 주소)에 접근 → 이 참조값으로 객체에 접근 가능

<img alt="변수에객체할당" width="300" height="300" src="https://github.com/user-attachments/assets/ed21b1a8-634c-4d74-a9ac-24360b307e52" />

- 객체를 할당한 변수에선 변수는 객체를 참조 / 가리키고 있다라고 표현
- 원시값과 달리 객체는 변경 가능한 값
  - 객체를 할당한 변수는 재할당 없이 객체 직접 변경 가능
  - 재할당없이 프로퍼티 동적 추가, 삭제, 갱신 모두 가능

```jsx
person.name = 'Kim';

person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}
```

<img alt="변수에객체할당2" width="300" height="300" src="https://github.com/user-attachments/assets/4e20995e-9caf-41f5-a141-85c400d826d6" />

- 객체를 할당한 변수에 재할당을 하지 않았기에 변수의 참조 값 변경X
- 객체를 생성 및 관리하는데 효율적인 메모리 사용을 위해 객체는 변경 가능한 값으로 설계
  - 복사해 생성하는 비용 절약 → 성능 향상
  - 어느정도의 구조적 단점 감안한 설계
- 구조적 단점에 따른 부작용도 존재
  - 원시 값과 달리 여러 개의 식별자가 하나의 객체 공유 가능

### 얕은 복사와 깊은 복사

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

- 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사
- 깊은 복사는 객체에 중첩된 객체까지 모두 복사
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과 다른 객체!
  - 원본과 복사본은 참조값이 다른 별개의 객체
  - 얕은 복사: 객체에 중첩된 객체의 경우 참조 값을 복사
  - 깊은 복사: 객체에 중첩된 객체까지 모두 복사해 원시 값처럼 완전한 복사본 생성

```jsx
const v = 1;

// "깊은 복사"라고 부르기도 한다.
const c1 = v; // pass by value
console.log(c1 === v); // true

const o = { x: 1 };

// "얕은 복사"라고 부르기도 한다.
const c2 = o; // pass by reference
console.log(c2 === o); // true
```

- 깊은 복사: 원시 값을 할당한 변수를 다른 변수에 할당하는 것
- 얕은 복사: 객체를 할당한 변수를 다른 변수에 할당하는 것

## 11.2.2 참조에 의한 전달

### 여러 개의 식별자가 하나의 객체를 공유?

```jsx
var person = {
  name: 'Lee',
};

// 참조 값을 얕은 복사
var copy = person;
```

- 객체를 가리키는 변수를 다른 변수에 할당 시, 원본의 참조 값이 복사되어 전달!
  - **참조에 의한 전달**이라고 한다.

<img alt="참조에의한전달" width="600" height="300" src="https://github.com/user-attachments/assets/c02af3bf-9884-4bc5-a3c5-0c02a875e53e" />

- 서로 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다. → 동일한 객체를 가리킨다.
  - **두 개의 식별자가 하나의 객체를 공유**함을 의미
  - 원본 or 사본 중 어느 한쪽에서 객체 변경(프로퍼티 추가, 갱신, 삭제) 시 서로 영향을 주고 받게 된다.

```jsx
var person = {
  name: 'Lee',
};

// 참조 값을 복사(얕은 복사). copy와 person은 동일한 참조 값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person를 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // { name: 'Kim', address: 'Seoul' }
console.log(copy); // { name: 'Kim', address: 'Seoul' }
```

- *값에 의한 전달*과 *참조에 의한 전달*은 **식별자가 기억하는 메모리 공간에 저장된 값을 복사해서 전달**한다는 면에서 동일!
  - 식별자가 기억하는 메모리 공간, 변수에 저장된 값이 원시 값인지 참조 값인지 차이만 존재 ⇒ JS에선 참조에 의한 전달X 값에 의한 전달만이 존재한다고 할 수 있다. (변수에 저장된 값으로 판별하기때문)
- JS에선 이 같은 동작 방식 설명 용어가 명확히 존재하지 않기에 “**공유에 의한 전달**”이라고 표현하기도 하지만 이또한 ES 사양에 정의된 JS의 공식 용어는 아니다.

### 객체 관련 퀴즈

```jsx
var person1 = {
  name: 'Cho',
};

var person2 = {
  name: 'Cho',
};

console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```

1. 각 변수가 가리키는 객체의 내용은 같지만 다른 메모리에 저장된 별개의 객체
   - `person1` 변수와 `person2` 변수가 가리키는 참조 값은 전혀 다른 값 ⇒ false
2. 프로퍼티 값을 참조하는 `person1.name` 과 `person2.name` 은 값으로 평가될 수 있는 표현식
   - 두 표현식 모두 원시 값 `'Cho'` 로 평가 ⇒ true
