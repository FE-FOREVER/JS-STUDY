# 11장 원시 값과 객체의 비교

- [11.1 원시 값?](#111-원시-값)
- [11.2 객체](#112-객체)

JS가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체)은 크게 `원시 타입(primitive type)과` `객체 타입(object type)`으로 구분할 수 있다.

| **원시 타입(primitive type)**                                                  | **객체 타입(object type)**                                                          |
|----------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| 변경 불가능한 값 *(immutable value)*                                              | 변경 가능한 값 *(mutable value)*                                                      |
| 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장 된다.                                     | 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.                                           |
| 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. ⇒ 값에 의한 전달 *(pass by value)* | 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. ⇒ 참조에 의한 전달 *(pass by reference)* |

## 11.1 원시 값

### 변경 불가능한 값

> 원시 값은 변경 불가능한 값이다. 한번 생성된 원시 값은 읽기 전용 *(read only)* 값으로서 변경할 수 없다.
>
> **불변성**은 데이터의 신뢰성을 보장한다.
>
> “값을 변경할 수 없다” → 변수가 아니라 `값`에 대한 진술


**[ 변수 ≠ 값 ]**

- **변수**: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- **값**: 변수에 저장된 데이터, 표현식이 평가되어 생성된 결과

원시 값이 변경 불가능하다는 말은 **원시 값 자체를 변경할 수 없다**는 것, 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있다. → 따라서 변수라고 부르는 것

**[ 변수 ↔ 상수 ]**

상수는 **재할당이 금지된 변수**를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다.

변수의 반대 개념인 상수는 단 한 번만 할당을 허용, 재할당이 금지된다.

→ 따라서 변경 불가능한 값과 상수를 동일시 하는 것은 X

```jsx
const o = {}; // 상수: 재할당이 금지된 변수

// 변수에 할당한 원시 값(상수)은 변경 X
// 하지만 변수에 할당한 객체는 변경 가능
o.a = 1;
console.log(o); // {a: 1}
```

**[ 불변성: 원시 값은 변경 불가능한 값이다. ]**

1. 새로운 메모리 공간을 확보하고 재할당한 원시값을 저장한 후
2. 재할당한 원시 값을 가리킨다.
3. 변수가 참조하던 메모리 공간의 주소가 바뀐다.

- 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것 X
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.
  <img width="627" alt="11-1 원시 값은 변경 불가능한 값이다." src="https://github.com/user-attachments/assets/953efe98-f001-49d3-b5c9-f235b3f650df">

<br />

### 문자열과 불변성

> JS는 원시 타입인 문자열 타입을 제공한다. 문자열이 생성된 이후에는 변경할 수 없다.

```jsx
var str = 'Hello';
str = 'world';
```

- ‘Hello’를 수정하는 것이 아니라 새로운 문자열을 메모리에 생성하고 식별자 str이 이것을 가리킨다.
- 식별자 str은 ‘Hello’를 가리키고 있다가 ‘world’를 가리키도록 변경된 것 뿐이다.
- 따라서 ‘Hello’와 ‘world’는 모두 메모리에 존재한다.

**[ 유사 배열 객체 array-like object ]**

마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체

```jsx
var str = 'string';
console.log(s[0]); // s
console.log(str.length); // 6
```

**[ 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다. ]**

예기치 못한 변경으로부터 자유롭다. 이는 데이터의 신뢰성을 보장한다.

```jsx
var str = 'string';
s[0] = 'S';
console.log(str); // string
```

<br />

### 값에 의한 전달

> 공유에 의한 전달이라고 표현하는 경우도 있다.
>
> 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 **메모리 주소가 전달**되기 때문에 ‘값에 의한 전달’이라는 용어에 오해가 있을 수 있다.
>
> **식별자로 값을 구별해서 식별한다 = 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다**

변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다.

```jsx
var score = 80;
var copy = score;
score = 100;
console.log(score); // 100
console.log(copy); // 80
```

<img width="513" alt="11-3 값에 의한 전달" src="https://github.com/user-attachments/assets/c8ecaf22-d789-48bd-ac53-ec171c4d9c8e">

원시 값을 갖는 score 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값(80)이 복사되어 전달된다.

- score 변수와 copy 변수의 값 80은 **다른 메모리 공간에 저장된 별개의 값이다**.
- 어느 한쪽에서 `재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다`.

## 11.2 객체

**JS 객체의 관리 방식**

<img width="308" alt="11-6 해시 테이블" src="https://github.com/user-attachments/assets/54d7553a-34cf-4e46-bb0b-f34c5faac695">

- 프로퍼티 키를 인덱스로 사용하는 해시 테이블(hash table)이라고 생각할 수 있다.

  JS 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 해시 테이블보다 나은 방식으로 객체를 구현한다.

- JS는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다. 하지만 성능 면에서는 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이
  든다.
- 따라서 동적 탐색(dynamic lookup) 대신 히든 클래스(hidden class) 방식을 사용해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

### 변경 가능한 값

> 객체(참조) 타입의 값, 즉 객체는 **변경 가능한 값(mutable value)**이다.

**[ 원시 값을 할당한 변수 ]**

- 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **원시 값에 접근**할 수 있다.
- 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법 X
- `변수는 ㅁ값을 갖는다.`, `변수의 값은 ㅁ다.`

**[ 객체를 할당한 변수 ]**

- 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값에 접근**할 수 있다.
- 참조 값은 **생성된 객체가 저장된 메모리 공간의 주소, 그 자체**다
- **객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.**
- 객체를 할당한 변수는 재할당 없이 메모리에 저장된 객체를 직접 수정할 수 있다.

  → 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.

- `변수는 객체를 참조하고 있다.`, `변수는 객체를 가리키고(point) 있다.`

<img width="365" alt="11-7 객체의 할당" src="https://github.com/user-attachments/assets/acefcc3d-b8cb-4fbe-a2ee-e0fdc53a9640">

- 객체는 크기가 매우 클 수도 있고, 원시 값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다.

  ⇒ 메모리의 효율적 소비가 어렵고 성능이 나빠진다.

- 따라서 **객체는 변경 가능한 값**으로 설계되어 있다.
  - 메모리 사용의 효율성과 성능을 위해 구조적인 단점을 감안한 설계이다.
  - 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위함

이에 따른 단점 ⇒ `원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다.`

<br />

**[ 얕은 복사(shallow copy)와 깊은 복사(deep copy) ]**

- **얕은 복사**: 한 단계까지만 복사하는 것
  - **객체에 중첩되어 있는 객체의 경우 참조 값을 복사**
- **깊은 복사**: 객체에 중첩되어 있는 객체까지 모두 복사하는 것
  - 객체에 **중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본**을 만든다.

얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. → `원본과 복사본은 참조 값이 다른 별개의 객체다.`

<br />

### 참조에 의한 전달

> 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇을 의미하는가?
>
>
> 어떤 부작용이 발생하는가?
>

```jsx
var person = {
  name: 'Lee'
};

var copy = person;
```

1. 얕은복사로 `원본 person`을 `사본 copy`에 할당하면 **참조 값**이 복사되어 전달 **→ 참조에 의한 전달**

- **참조 값**: 생성된 메모리 공간의 주소가 저장된 공간 그 자체

2. 원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다.

   **⇒ 둘 다 동일한 객체를 가리킨다, 두 개의 식별자가 하나의 객체를 공유한다는 것**

   ⇒ 원본 또는 사본 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.

- 이 때 변경은 새로운 객체를 재할당 X, 프로퍼티 값을 변경, 추가, 삭제를 말함

3. 값에 의한 전달, 참조에 의한 전달은 식별자가 기억하는 **메모리 공간에 저장되어 있는** `값`**을 복사해서 전달**한다는 면에서 동일함

   다만 식별자가 기억하는 `메모리 공간 === 변수에 저장되어 있는 값`이 `원시 값이냐?` `참조 값(메모리 주소)이냐?` 의 차이

   JavaScript에서는 모든 변수가 **값에 의한 전달**로 동작한다.

4. **따라서 JS 에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다.**

   참조 값을 `‘값’`으로 전달할 뿐이다.


- 하지만 이 용어들은 JS 공식적인 용어는 아님

  다만 책에서는 **전달되는 값의 종류**가 원시 값인지 **구별해서 강조**하는 의미에서 `값에 의한 전달`과 `참조에 의한 전달`로 구분하여 부름

### 예제

```jsx
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // false ... (1)
console.log(person1.name === person2.name); //true ... (2)
```

- **(1):** 객체를 할당한 변수는 참조 값을 가지고 있다. 따라서 (1)은 참조 값을 비교한다.

  두 객체의 내용은 같지만 다른 메모리에 저장된 별개의 객체다.

- **(2):** 프로퍼티 값을 참조하는 `person1.name`과 `person2.name`은 값으로 평가될 수 있는 표현식이다.

  두 표현식 모두 원시 값 ‘Lee’로 평가된다.
