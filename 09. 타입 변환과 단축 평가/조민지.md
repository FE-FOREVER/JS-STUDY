### 🔍 이 장의 keyword!

> 타입 변환, 명시적 타입 변환, 암묵적 타입 변환, 예측 가능성, Truthy 값, Falsy 값, 의도, 단축 평가, `?.` , `??`

## 목차

1. [타입 변환이란?](#91-타입-변환이란)
2. [암묵적 타입 변환](#92-암묵적-타입-변환)
3. [명시적 타입 변환](#93-명시적-타입-변환)
4. [단축 평가](#94-단축-평가)

# 9.1 타입 변환이란?

JS의 모든 값엔 타입이 존재하고, 값의 타입은 다른 타입으로 변환될 수 있다.

타입 변환의 종류에는 명시적, 암묵적 타입 변환이 있다.

타입 변환이란 기존 원시 값은 그대로 두고, 그를 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

## 타입 변환의 종류

### 명시적 타입 변환

- Type Casting이라고도 한다.
- 개발자가 의도적으로 값의 타입을 변환하는 것

### 암묵적 타입 변환

- Type Coercion(타입 강제 변환)이라고도 한다.
- 개발자 의도X 표현식 평가 중 JS 엔진에 의해 암묵적으로 타입이 자동 변환되는 것

## 타입 변환의 특징

### 공통

- 타입 변환 시 기존 원시 값 직접 변경 X → 원시 값은 변경 불가능한 값!
  - **타입 변환**은 **기존 원시 값을 사용**해 **_다른 타입의 새로운 원시 값을 생성_**하는 것

### 명시적 타입 변환

- 타입 변경 의지가 코드에 명확

### 암묵적 타입 변환

- 기존 변수 값에 재할당 발생 X → 표현식을 에러 없이 평가하기 위해 **JS 엔진**이 일회성으로 피연산자의 값을 암묵적 타입 변환
- 암묵적으로, 드러나지 않게 타입 자동 변환 발생 → 코드 상 타입 변경 의지 X

## 타입 변환 예측 중요성

타입 변환 발생 가능성이나 변환 시 변환되는 값, 그 값으로 인해 달라지는 표현식의 평가 결과들은 예측 가능해야 한다. ⇒ 예측 실패 시 오류 생산 가능성 ↑

암묵적 타입 변환은 명백한 의지가 나타나지 않더라도, 가독성 측면에서 더 간결하고 이해하기 쉬울 수 있다.

따라서 어떠한 형태의 타입 변환이든 코드를 정확히 이해하며 예측할 수 있는 자세가 중요하다!

# 9.2 암묵적 타입 변환

JS 엔진은 표현식 평가 시 개발자 의도와 상관 없이 코드의 문맥에 따라 암묵적으로 타입을 강제 변환한다.

⇒ 가급적 에러 발생의 최소화를 위한 JS의 특징으로 코드의 문맥에 부합하지 않는 다양한 상황에서도 암묵적 타입 변환으로 표현식을 평가한다.

암묵적 타입 변환 시 문자열, 숫자, 불리언 3개의 타입 중 하나로 타입을 자동 변환한다.

## 9.2.1 문자열 타입으로 변환

### 문자열 연결 연산자(`+`)

- 문자열 값을 만드는 역할
  - 모든 피연산자가 코드 문맥상 모두 문자열 타입일 것
  - 피연산자 중 하나라도 문자열 타입인 경우 문자열 연결 연산자로 동작
- 문자열 타입이 아닌 피연산자가 있는 경우 모두 문자열 타입으로 암묵적 변환

### 템플릿 리터럴

- 템플릿 리터럴에 삽입된 표현식의 결과를 문자열 타입으로 암묵적 타입 변환
- `11 + 3 = ${11 + 3}` → `"11 + 3 = 14"`

### 변환 예시

- 숫자 타입
  - `-0 + ''` → `“0”` , `-1 + ''` → `"-1"`
  - NaN, Infinity, -Infinity도 그대로 문자열 형태로 변환 → `"NaN"` , `"-Infinity"` …
- 불리언 타입
  - true, false 모두 그대로 문자열 타입 변환 → `"true"` …
- null 타입
  - 그대로 변환 → `"null"`
- undefined 타입
  - 그대로 변환 → `"undefined"`
- **심벌 타입 → 변환 불가** (TypeError 발생)
- 객체 타입
  - `({}) + ''` → `"[object Object]"`
    - **객체를 소괄호로 감싸야** `+`가 문자열 연결 연산자로 작동
  - `[] + ''` → `""` , `[10, 20] + ''` → `"10,20"`
    - 배열의 경우 문자열 변환 시 대괄호가 사라진다.

## 9.2.2 숫자 타입으로 변환

### 산술 연산자(`-` , `*` , `/` , `+` )

- 숫자 값을 만드는 역할
  - 모든 피연산자가 코드 문맥상 숫자 타입일 것
- 산술 연산자 표현식 평가 위해 숫자 타입이 아닌 피연산자가 있는 경우 숫자 타입으로 암묵적 타입 변환
  - 피연산자가 숫자 타입으로 변환 불가한 경우 `NaN` 반환 ⇒ 산술 연산 수행 불가니까

### 비교 연산자(`>` , `<` , `<=` , `>=` )

- 불리언 값을 만드는 역할
  - 피연산자의 크기 비교를 위해 모든 피연산자가 숫자 타입일 것
- 비교 연산자 표현식 평가 위해 문자열 타입이 아닌 피연산자가 있는 경우 숫자 타입으로 암묵적 타입 변환

### 변환 예시

- 문자열 타입
  - `+''` → `0` , `+'string'` → `NaN`
- 불리언 타입
  - `+true` → `1`, `+false` → `0`
- null 타입
  - **`+null` → `0`**
- undefined 타입
  - **`+undefined` → `NaN`**
- 심벌 타입
  - **심벌 타입 → 변환 불가** (TypeError 발생)
- 객체 타입
  - `+{}` → `NaN`
  - `+[]` → `0` , `+[1,2]` → `NaN`

⇒ ⚠️객체와 원소가 존재하는 배열, undefined는 변환 X → `NaN`

빈 문자열, 빈 배열, null, false는 `0` , true는 `1`

## 9.2.3 불리언 타입으로 변환

### 제어문 or 삼항 조건 연산자의 조건식

- 논리적 참/거짓으로 평가되어야 하는 조건식
  - JS엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환
- 불리언 타입이 아닌 값을 Truthy 값, Falsy 값으로 구분
  - 불리언 값으로 평가되어야 할 때, Truthy → true, Falsy → false 암묵적 타입 변환

### Falsy 값

- false, undefined, null, 0, -0, NaN, ‘’(빈 문자열)
  - 위 값들은 모두 false로 평가된다. 이를 제외한 값들은 모두 true로 평가된다.(Truthy 값)
- 조건식 내부에서 부정연산자를 취하면, true로 평가되는 값 `!false`

### Truthy 값 & 판별 예시

`!!'0'` → `true` ⇒ 빈 문자열이 아닌 문자열은 Truthy 값

`!!{}` , `!![]` → true

# 9.3 명시적 타입 변환

### 다양한 명시적 타입 변환 방법

1. 표준 빌트인 생성자 함수(`String`, `Number`, `Boolean`)를 `new` 연산자 없이 호출
2. 빌트인 메서드 사용

❓ 표준 빌트인 생성자 함수 & 빌트인 메서드

- JS에서 기본 제공하는 함수
- 표준 빌트인 생성자 함수: 객체 생성용 함수 → new 연산자와 함께 호출
- 표준 빌트인 메서드: JS에서 기본 제공하는 빌트인 객체의 메서드
  - 21장. 빌트인 객체에서 자세히 알아보자.

## 9.3.1 문자열 타입으로 변환

1. `String` 생성자 함수를 new 연산자 없이 호출하는 방법
   - 숫자 타입 ⇒ 문자열 타입
     - `String(1);` , `String(NaN);`
   - 불리언 타입 ⇒ 문자열 타입
     - `String(true);`
2. `Object.prototype.toString` 메서드를 사용하는 방법
   - 숫자 타입 ⇒ 문자열 타입
     - `(1).toString();`
   - 불리언 타입 ⇒ 문자열 타입
     - `(false).toString();`
   - 두 경우 **모두 값에 소괄호** 붙여주기! Syntax Error 발생 방지.
3. 문자열 연결 연산자(`+`)를 이용하는 방법
   - `Infinity + '';` , `true + '';`

## 9.3.2 숫자 타입으로 변환

1. `Number` 생성자 함수를 new 연산자 없이 호출하는 방법
   - 문자열 타입 ⇒ 숫자 타입
     - `Number('-1');` → -1 , `Number('11.03');` → 10.53
   - 불리언 타입 ⇒ 숫자 타입
     - `Number(false);` → 0
2. `parseInt` , `parseFloat` 함수를 사용하는 방법 ⇒ **문자열만** 숫자 타입으로 변환 가능
   - `parseInt('0');` , `parseFloat('11.03');`
3. `+` 단항 산술 연산자를 이용하는 방법
   - 문자열 타입 ⇒ 숫자 타입
     - `+'-1';`
   - 불리언 타입 ⇒ 숫자 타입
     - `+true;`
4. `*` 산술 연산자를 이용하는 방법
   - 문자열 타입 ⇒ 숫자 타입
     - `'0' * 1;`
   - 불리언 타입 ⇒ 숫자 타입
     - `false * 1`

✔︎ JS에서 Number 타입은 실수를 포함하기에 숫자형으로 변환 시 실수는 실수 형태로 올바르게 나타난다! `parseInt()` 를 사용하지 않는다면~

## 9.3.3 불리언 타입으로 변환

1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
   - 문자열 타입 ⇒ 불리언 타입
     - `Boolean('x');` , `Boolean(’false’);` ⇒ true
     - `Boolean('');` ⇒ false
   - 숫자 타입 ⇒ 불리언 타입
     - `Boolean(1);` , `Boolean(Infinity);` ⇒ true
     - `Boolean(0);` , `Boolean(NaN);` ⇒ false
   - null 타입 ⇒ 불리언 타입
     - `Boolean(null);` ⇒ false
   - undefined 타입 ⇒ 불리언 타입
     - `Boolean(undefined);` ⇒ false
   - 객체 타입 ⇒ 불리언 타입
     - `Boolean({});` ⇒ true
     - `Boolean([]);` ⇒ true
     - ✔️ 빈 배열과 빈 객체는 Truthy 값!! 빈 문자열만 Falsy다~~
2. !부정 논리 연산자를 두 번(`!!`) 사용하는 방법
   - 문자열 타입 ⇒ 불리언 타입
     - `!!'x';` , `!!'false';` ⇒ true
     - `!!'';` ⇒ false
   - 숫자 타입 ⇒ 불리언 타입
     - `!!1;` , `!!-Infinity;` ⇒ true / ✔️`-Infinity` 도 Truthy 값이다 ~~
     - `!!0;` , `!!NaN;` ⇒ false
   - null 타입 ⇒ 불리언 타입
     - `!!null;` ⇒ false
   - undefined 타입 ⇒ 불리언 타입
     - `!!undefined;` ⇒ false
   - 객체 타입 ⇒ 불리언 타입
     - `!!{};` , `!![];` ⇒ true

# 9.4 단축 평가

## 9.4.1 논리 연산자를 사용한 단축 평가

### 논리곱 연산자(`&&`)

- 두 개의 피연산자 모두 true로 평가될 때 true 반환!
- 좌항이 Truthy 값이어도 우항까지 평가해봐야한다. `'Cat' && 'Dog'` ⇒ “Dog”

⇒ 논리 연산의 결과는 두 번째 피연산자가 결정!

### 논리합 연산자(`||`)

- 두 개의 피연산자 중 하나만 true여도 true를 반환
- 좌항이 Truthy 값이라면 우항까지 평가해보지 않아도 된다. `'Cat' || 'Dog'` ⇒ “Cat”

⇒ 논리 연산의 결과는 첫 번째 피연산자가 결정!

### 단축 평가?

표현식 평가 중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

논리곱과 논리합 연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다! 따라서 단축 평가를 수행한다고 할 수 있다.

| **단축 평가 표현식**  | **평가 결과** |
| --------------------- | ------------- |
| `true \|\| anything`  | `true`        |
| `false \|\| anything` | `anything`    |
| `true && anything`    | `anything`    |
| `false && anything`   | `false`       |

### if문 대체

단축 평가를 이용해 If문 대체가 가능하다.

- 논리곱 연산자(`&&`): 어떤 조건이 참으로 평가되는 값일 때
  - `if (done) message = '완료';` ⇒ `message = done && '완료';`
- 논리합 연산자(`||`): 어떤 조건이 거짓으로 평가되는 값일 때
  - `if (!done) message = '미완료';` ⇒ `message = done || '미완료';`

### 삼항 조건 연산자의 If…else문 대체

아래와 같이 더 간결한 표현 가능

```jsx
var done = true;
var message = '';

if (done) message = '완료';
else message = '미완료';

message = done ? '완료' : '미완료';
```

### 단축 평가의 유용한 패턴 두 가지

1. 객체를 가리키기를 기대하는 변수 값이 null or undefined인지 확인하고 프로퍼티를 참조할 때
   - 객체가 아니라 null or undefined인 경우 객체의 프로퍼티를 참조하면 TypeError 발생
     - `var value = elem && elem.value;`
       - 이런 단축평가 형태로 작성하면 `elem` 이 Falsy 값일 땐 `elem`으로 평가, Truthy 값이면 `elem.value`로 평가!
2. 함수 매개변수에 기본 값을 설정할 때

   - 함수 호출 시 인수를 전달하지 않으면 매개변수에 undefined가 할당 → 단축 평가 사용으로 매개변수 기본값 설정해 undefined 시 발생할 수 있는 에러 사전 방지 가능

   ```jsx
   // 단축 평가 사용한 매개변수 기본값 설정
   function getStringLength(str) {
     str = str || '';
     return str.length;
   }

   // ES6의 매개변수 기본값 설정
   function getStringLength2(str = '') {
     return str.length;
   }
   ```

   - `str = str || '';` 형태처럼 사용 가능하며 str이 undefined이라면 빈 문자열로!
   - 두 방식 모두 반환 결과는 동일

## 9.4.2 옵셔널 체이닝 연산자 (`?.`)

- ES11에서 도입 → 도입 이전엔 보통 논리곱 연산자(`&&`)를 사용
  - 논리곱 연산자는 좌항 피연산자가 Falsy 값인 경우 좌항 피연산자를 그대로 반환
  - 위 상황은 0이나 빈문자열의 경우에도 동일 → 이 둘은 객체로 평가될 때도 있어 원하는 값을 얻지 못할 수 있다. `var length = str && str.length;` ⇒ 문자열 길이 참조 불가
  - 옵셔널 체이닝 연산자의 경우 좌항 피연산자가 Falsy값이라도 null 혹은 undfined가 아니라면 **우항의 프로퍼티 참조를 이어간다.** `var length = str?.length;`
- 좌항의 피연산자가 null or undefined인 경우 undefined 반환, 그렇지 않으면 우항의 프로퍼티 참조 계속
- `var value = elem?.value;`
- 객체를 가리키기를 기대하는 변수가 null or undefined가 아닌지 확인 및 객체 프로퍼티 참조 시 유용!

⇒ 원하는 결과 도출을 위해 이 상황에선 논리곱 연산자보다 옵셔널 체이닝 연산자를 사용하도록 하자!

## 9.4.3 null 병합 연산자(`??`)

- ES11에서 도입 → 도입 이전엔 논리합 연산자 (`||`)를 사용
  - 논리합 연산자는 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환
  - 여기서도 0이나 빈문자열이 기본값으로 유효하다면 예측하지 못한 동작 발생 가능!! `var foo = '' || 'default string';` ⇒ “default string”
  - null 병합 연산자는 좌항의 피연산자가 false로 평가되는 Falsy 값이라도 null 혹은 undfined가 아니라면 **좌항의 피연산자를 그대로 반환** `var foo = '' ?? 'default string';` ⇒ “”
- 좌항의 피연산자가 null or undefined인 경우 우항의 피연산자 반환, 그렇지 않으면 좌항의 피연산자 반환
- `var foo = null ?? 'default string';` ⇒ “default string”
- 변수에 기본값 설정 시 유용

⇒ 원하는 결과 도출을 위해 이 상황에선 논리합 연산자보다 null 병합 연산자를 사용하도록 하자!
