### 🔍 이 장의 keyword!

> 산술, 할당, 비교, 삼항 조건, 논리, 쉼표, 그룹, typeof, 지수 연산자, 부수 효과, 우선순위, 결합 순서

## 목차

1. [산술 연산자](#71-산술-연산자)
2. [할당 연산자](#72-할당-연산자)
3. [비교 연산자](#73-비교-연산자)
4. [삼항 조건 연산자](#74-삼항-조건-연산자)
5. [논리 연산자](#75-논리-연산자)
6. [쉼표 연산자](#76-쉼표-연산자)
7. [그룹 연산자](#77-그룹-연산자)
8. [typeof 연산자](#78-typeof-연산자)
9. [지수 연산자](#79-지수-연산자)
10. [그 외의 연산자](#710-그-외의-연산자)
11. [연산자의 부수 효과](#711-연산자의-부수-효과)
12. [연산자 우선순위](#712-연산자-우선순위)
13. [연산자 결합 순서 ](#713-연산자-결합-순서)

## 연산자

- 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값 생성
- 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.
- 피연산자: 연산의 대상, 값으로 평가될 수 있는 표현식일 것
- 연산자 표현식: 피연산자와 연산자의 조합, 값으로 평가될 수 있는 표현식이다.

# 7.1 산술 연산자

피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값 생성!

산술 연산이 불가한 경우 NaN 반환

## 7.1.1 이항 산술 연산자

2개의 피연산자를 산술 연산

모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과 X ⇒ 어떤 산술 연산을 해도 피연산자 값 변경 X 언제나 새로운 값 생성!

### 이항 산술 연산자의 종류

1. `+` : 덧셈
2. `-` : 뺄셈
3. `*` : 곱셈
4. `/` : 나눗셈
5. `%` : 나머지

## 7.1.2 단항 산술 연산자

1개의 피연산자를 산술 연산해 숫자 값 생성

증가/감소 연산자의 경우 부수효과 발생! → 피연산자 값을 변경하는 암묵적 할당 발생

### 단항 산술 연산자의 종류

1. `++` : 증가, **부수효과 O**
2. `--` : 감소, **부수효과 O**
3. `+` : 효과 X, 음수를 양수로 반전하지도 X
   - 숫자 타입이 아닌 피연산자에 사용 시 피연산자를 숫자 타입으로 변환해 반환!
4. `-` : 양수를 음수로, 음수를 양수로 반전한 값 반환

### 증가/감소 연산자의 위치에 따른 의미

1. 전위 증가/감소 연산자 (`++a, —b` )
   - 피연산자 앞에 위치 ⇒ 피연산자의 값을 먼저 증가/감소시킨 후, 다른 연산 수행
2. 후위 증가/감소 연산자 (`a++, b—` )
   1. 피연산자 뒤에 위치 ⇒ 먼저 다른 연산 수행 후, 피연산자 값 증가/감소

```jsx
var x = 4,
  result;

// 선할당 후증가
result = x++;
console.log(result, x); // 4, 5

// 선증가 후할당
result = ++x;
console.log(result, x); // 6, 6

// 선할당 후감소
result = x--;
console.log(result, x); // 6, 5

// 선감소 후할당
result = --x;
console.log(result, x); // 4, 4
```

## 7.1.3 문자열 연결 연산자

`+` 연산자 → 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작!

### 암묵적 타입 변환 (타입 강제 변환)

개발자 의도 상관 X JS 엔진에 의해 암묵적 타입 자동 변환의 경우도 발생 ex) `1 + true` → 2 , true = 1

# 7.2 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당!

좌항의 변수에 값을 할당하므로 변수 값이 변하는 **부수 효과** 발생

## 할당 연산자 종류

| 할당 연산자 | 예      | 동일 표현  | 부수 효과 |
| ----------- | ------- | ---------- | --------- |
| =           | x = 3   | x = 3      | O         |
| +=          | x += 3  | x = x + 3  | O         |
| -=          | x -= 3  | x = x - 3  | O         |
| \*=         | x \*= 3 | x = x \* 3 | O         |
| /=          | x /= 3  | x = x / 3  | O         |
| %=          | x %=3   | x = x % 3  | O         |

할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다!

`x=5` 는 x에 할당된 값 `5` 로 평가 ⇒ 할당문을 다른 변수에 할당할 수도 있다. 여러 변수에 동일 값 연쇄 할당 가능

```jsx
var a, b, c;

a = b = c = 3;
```

# 7.3 비교 연산자

좌항과 우항의 피연산자 비교 후 그 결과를 불리언 값으로 반환

## 7.3.1 동등/일치 비교 연산자

동등 비교 연산자와 일치 비교 연산자는 비교 시 엄격성의 차이 조재

### 비교 연산자 종류

부수 효과는 모두 없다.

| 비교 연산자 | 의미        | 사례    | 설명                     |
| ----------- | ----------- | ------- | ------------------------ |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음        |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음 |
| ≠           | 부동등 비교 | x ≠ y   | x와 y의 값이 다름        |
| ≠=          | 불일치 비교 | x ≠=y   | x와 y의 값과 타입이 다름 |

### 동등 비교 연산자

좌항과 우항의 피연산자 비교 시 우선 암묵적 타입 변환으로 타입을 일치시킨 후 같은 값인지 비교

⇒ 서로 다른 타입의 피연산자여도 암묵적 타입 변환 후 같은 값이라면 true를 반환

편리한 경우도 있지만 결과 예측이 어렵고 실수가 쉬운 단점 존재 → 안티 패턴도 존재하기에 사용 지양

### 일치 비교 연산자

좌항과 우항의 피연산자가 타입과 값이 모두 같은 경우에 한해 true를 반환 ⇒ 암묵적 타입 변환 X

예측이 쉽다.

but, NaN의 경우 `NaN === NaN` 의 결과 false가 나타난다. `Number.isNaN` 을 사용할 것

숫자 0 또한 양의 0과 음의 0이 모두 동일하게 비교된다.

### [Object.is](http://Object.is) 메서드

위의 예시의 NaN과 양의 0, 음의 0을 올바르게 비교 가능

`Object,is(-0, +0)` // false 출력

`Object.is(NaN, NaN)` // true 출력

## 7.3.2 대소 관계 비교 연산자

피연산자의 크기를 비교해 불리언 값 반환

모두 부수 효과는 없다.

### 대소 관계 비교 연산자 종류

1. `>`
2. `<`
3. `>=`
4. `<=`

# 7.4 삼항 조건 연산자

조건식의 평가 결과에 따라 반환 값 결정

JS의 유일한 삼항 연산자 , 부수 효과 X

`조건식 ? 조건식 true일 때 반환 값 : 조건식 false일 때 반환 값` 형태

⇒ 두 번째 피연산자 또는 세번째 피연산자로 평가되는 표현식

조건식은 불리언 타입의 값으로 평가될 표현식 → 만약 조건식 평가 결과가 불리언 값이 아닌 경우 암묵적으로 불리언 값으로 타입 변환이 진행된다.

삼항 조건연산자의 첫 번째 피연산자가 조건식이므로 해당 표현식은 조건문이다. if…else문으로 삼항 조건 연산자와 유사하게 처리 가능 but, if…else문은 값처럼 사용 불가(표현식이 아닌 문이기에)

“값으로 평가할 수 있는 표현식인 문” → 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용

### if…else vs 삼항 조건 연산자

조건에 따라 어떤 값 결정 필요 시 삼항 조건 연산자 사용

조건에 따라 수행 할 문이 여러 개일 땐 if…else문 사용

# 7.5 논리 연산자

우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산이라 의미

모두 부수 효과 X

## 논리 연산자 종류

1. || : 논리합(OR)
2. &&: 논리곱(AND)
3. !: 부정(NOT)

   → 언제나 논리 부정 연산자는 불리언 값 반환

논리합 또는 논리곱 연산자 표현식의 평가 결과는 불리언 값 아닐 수도 있다. 언제나 2개의 피연산자 중 한 쪽으로 평가된다.

### 드모르간의 법칙?

논리 연산자로 구성된 복잡한 표현식의 가독성 향상을 위해 활용하는 법칙!

```jsx
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

# 7.6 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가해 마지막 피연산자의 평가가 끝나면 평가 결과를 반환

```jsx
var x, y, z;

(x = 1), (y = 2), (z = 3); // 3을 반환
```

# 7.7 그룹 연산자

소괄호로 피연산자를 감싸는 연산자!

자신의 피연산자인 표현식(소괄호로 감싸진 표현식)을 가장 먼저 평가

그룹 연산자의 우선 순위가

가장 높다 !! → 그룹 연산자로 연산자 우선순위 조절 가능

```jsx
// 수학에서와 마찬가지로 곱셈 연산자의 우선 순위가 덧셈 연산자보다 높다.
10 * 3 + 5; // 35

// 그룹 연산자를 사용해 우선순위 조절
10 * (3 + 5); // 80
```

# 7.8 typeof 연산자

피연산자의 데이터 타입을 문자열로 반환

`typeof 피연산자` 형태

## typeof 연산자의 반환 종류

| 데이터 타입 | 피연산자 예시                                    |
| ----------- | ------------------------------------------------ |
| string      | `‘ ‘`                                            |
| number      | `1`, `NaN`                                       |
| boolean     | `true`, `false`                                  |
| undefined   | `undefined`                                      |
| symbol      | `Symbol()`                                       |
| object      | `null` , `[]` , `{}` , `new Date()` , `/test/gi` |
| function    | `function () {}`                                 |

### typeof 연산자 사용 시 주의점

⚠️ null 값의 경우 object를 반환한다. ⇒ 따라서 null 값이 반환되는 경우는 없다.

→ null 타입인지 확인할 땐 `typeof` 보다 `일치 연산자(===)` 를 사용하기

```jsx
var foo = null;

typeof foo === null; // typeof foo 결과가 null인가? object !== null -> false
foo === null; // foo의 값이 null인가? foo === null -> true
```

⚠️선언하지 않은 식별자를 `typeof` 연산자로 연산했을 때 undefined를 반환한다. → ReferenceError 발생이 아님을 유의! → 얘도 호이스팅과 연관 있는 걸까?

`typeof undeclared;` → undeclared란 식별자를 한 번도 선언하지 않았다고 가정했을 때 undefined 반환

# 7.9 지수 연산자

- ES7에서 도입 `밑 ** 지수` 형태
- 좌항의 피연산자가 밑(base)이며 우항의 피연산자가 지수(exponent)의 역할로 거듭제곱해 숫자 값 반환
- 지수 연산자 도입 이전엔 `Math.pow()` 이용
  `3 ** 3;` === `Math.pow(3, 3);`

## 지수 연산자의 특징

아래와 같은 경우에선 `Math.pow()` 보다 지수 연산자의 사용이 가독성 ↑

✔︎지수 연산자의 결합 순서는 우항 → 좌항으로, 우결합성을 가짐

```jsx
2 ** (3 ** 2); // 512
Math.pow(2, Math.pow(3, 2)); // 512
```

⚠️ 음수를 거듭제곱의 밑으로 사용해 계산하려면 음수를 괄호로 묶어야 사용 가능

```jsx
-5 ** 2; // SyntaxError 발생

(-5) ** 2; // 25
```

다른 산술 연산자처럼 할당 연산자와 함께 사용 가능

```jsx
var num = 5;

num **= 2; // 25
```

이항 연산자 중 우선순위가 가장 높다.
ex) `3 * 5 ** 2;` → 3 \* (5 \*\* 2) 형태로 계산 되어 75 반환

# 7.10 그 외의 연산자

| 연산자     | 개요                                                      | 참고(더 알아볼 곳)             |
| ---------- | --------------------------------------------------------- | ------------------------------ |
| ?.         | 옵셔널 체이닝 연산자                                      | 9.4.2절 “옵셔널 체이닝 연산자” |
| ??         | null 병합 연산자                                          | 9.4.3절 “null 병합 연산자”     |
| delete     | 프로퍼티 삭제                                             | 10.8절 “프로퍼티 삭제”         |
| new        | 생성자 함수 호출 시 사용해 인스턴스 생성                  | 17.2.6절 “new 연산자”          |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴인지 판별 | 19.10절 “instanceof 연산자”    |
| in         | 프로퍼티 존재 확인                                        | 19.13.1절 “in 연산자”          |

# 7.11 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향 X ⇒ 피연산자 자체의 값이 변하는 부수 효과 발생 X

## 부수효과가 있는 연산자

1. 할당 연산자(`=`) : 변수 값 자체가 변경 → 해당 변수 사용하는 다른 코드에 영향
2. 증가/감소 연산자(`++` / `--` ): 피연산자 값 변경하는 부수 효과가 있어, 피연산자의 값이 재할당되어 변경 → 해당 변수 사용하는 다른 코드에 영향
3. `delete` 연산자: 객체의 프로퍼티를 삭제하는 부수 효과 → 객체를 사용하는 다른 코드에 영향

```jsx
var x;

x = 1;
console.log(x); // 1

x++;
console.log(x); // 2

var o = { a: 1 };

delete o.a;
console.log(o); // {}
```

# 7.12 연산자 우선순위

여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 의미

우선순위가 높을수록 먼저 실행
| 우선순위 | 연산자 |
| --- | --- |
| 1 | () |
| 2 | new(매개변수 존재), . or [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자) |
| 3 | new(매개변수 미존재) |
| 4 | x++, x— |
| 5 | !x, +x, -x, ++x, —x, typeof, delete |
| 6 | \*_(이항 연산자 중 우선 순위 가장 ↑) |
| 7 | _, /, % |
| 8 | +, - |
| 9 | <. ≤, >, ≥, in, instanceof |
| 10 | ==, ≠, ===, ≠= |
| 11 | ?? (null 병합 연산자) |
| 12 | && |
| 13 | || |
| 14 | ? … : … |
| 15 | 할당 연산자(=, +=, -=, …) |
| 16 | , |

→ 이렇게 연산자 종류가 많기에 연산자 우선 순위를 모두 기억하기도 어렵고 실수도 쉽다. 연산자 우선순위가 가장 높은 **그룹 연산자**를 이용해 **우선순위를 명시적으로 조절**해보자!

# 7.13 연산자 결합 순서

연산자의 어느쪽(좌항 or 우항)부터 평가를 수행할 것인지 나타내는 순서를 의미
| 결합 순서 | 연산자 |
| --- | --- |
| 좌항 → 우항 | +, -, /, %, <, ≤, >, ≥, &&, ||, ., [], (), ??, ?., in, instanceof |
| 우항 → 좌항 | ++, —, 할당 연산자(=,+=,-=,…), !x, +x, -x, ++x, —x, typeof, delete, ?… : …, \*\* |
